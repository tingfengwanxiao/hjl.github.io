<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LiangLab</title>
    <link>http://localhost:4000/</link>
    <description></description>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <atom:link rel="hub" href="http://pubsubhubbub.appspot.com"/>
    <pubDate>Thu, 23 Jun 2022 21:59:57 +0800</pubDate>
    <lastBuildDate>Thu, 23 Jun 2022 21:59:57 +0800</lastBuildDate>
    <generator>Jekyll v4.2.2</generator>
    
      <item>
        <title>Vim：tab设置</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#tabstop&quot; id=&quot;markdown-toc-tabstop&quot;&gt;tabstop&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#expandtab&quot; id=&quot;markdown-toc-expandtab&quot;&gt;expandtab&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#softtabstop&quot; id=&quot;markdown-toc-softtabstop&quot;&gt;softtabstop&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#shiftwidth&quot; id=&quot;markdown-toc-shiftwidth&quot;&gt;shiftwidth&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#smarttab&quot; id=&quot;markdown-toc-smarttab&quot;&gt;smarttab&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#notice&quot; id=&quot;markdown-toc-notice&quot;&gt;Notice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;tabstop&quot;&gt;tabstop&lt;/h4&gt;

&lt;p&gt;一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\t&lt;/code&gt;被解释成的长度&lt;/p&gt;

&lt;h4 id=&quot;expandtab&quot;&gt;expandtab&lt;/h4&gt;

&lt;p&gt;是否将&lt;strong&gt;从Vim输入的&lt;/strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\t&lt;/code&gt;转换成空格&lt;/p&gt;

&lt;h4 id=&quot;softtabstop&quot;&gt;softtabstop&lt;/h4&gt;

&lt;p&gt;Insert模式下，按下tab后显示的空格长度，如果expandtab开启，那将只输出对应长度的空格，按下backspace将删除对应长度。如果expandtab没有开启，那输出将混合&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\t&lt;/code&gt;和空格。&lt;/p&gt;

&lt;h4 id=&quot;shiftwidth&quot;&gt;shiftwidth&lt;/h4&gt;

&lt;p&gt;Normal模式下，”»“或”«“行首缩进的长度，不会智能控制（不会管之前已经有多少个空格），按下后就会添加或减少对应个数的空格。如果expandtab开启，则转换为对应的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\t&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;smarttab&quot;&gt;smarttab&lt;/h4&gt;

&lt;p&gt;如果开启，Insert模式下，在第一个可见字符钱，按下tab增加的长度将会是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shiftwidth&lt;/code&gt;长度个，会根据已有的空格智能控制。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;set ts=5 noet sts=6&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;notice&quot;&gt;Notice&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;已有文件中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\t&lt;/code&gt;一定不会变成空格&lt;/li&gt;
  &lt;li&gt;如果expandtab关闭，再空格后按下tab，会只能生成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\t&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;当前设置:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set ts=5 sts=8 sw=5 sta 
set listchars=tab:&amp;lt;-&amp;gt;
&quot; set list &quot; 显示tab, 还可以显示eol，显示空格等等
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2020-07-21T00:00:00+08:00&quot;&gt;
                2020-07-21
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Tue, 21 Jul 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/07/21/VimTabs/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/07/21/VimTabs/</guid>
        
        
        <category>Vim</category>
        
      </item>
    
      <item>
        <title>ZOJ1008题解(Java)与优化心得</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#题目&quot; id=&quot;markdown-toc-题目&quot;&gt;题目&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#输入&quot; id=&quot;markdown-toc-输入&quot;&gt;输入&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#输出&quot; id=&quot;markdown-toc-输出&quot;&gt;输出&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#分析与第一次尝试&quot; id=&quot;markdown-toc-分析与第一次尝试&quot;&gt;分析与第一次尝试&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#优化&quot; id=&quot;markdown-toc-优化&quot;&gt;优化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#继续优化&quot; id=&quot;markdown-toc-继续优化&quot;&gt;继续优化&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#如果有小正方形一样怎么办&quot; id=&quot;markdown-toc-如果有小正方形一样怎么办&quot;&gt;如果有小正方形一样怎么办？&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#重构&quot; id=&quot;markdown-toc-重构&quot;&gt;重构&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#永无止境的优化&quot; id=&quot;markdown-toc-永无止境的优化&quot;&gt;永无止境的优化&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#为什么还是超了&quot; id=&quot;markdown-toc-为什么还是超了&quot;&gt;为什么还是超了？&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#实现&quot; id=&quot;markdown-toc-实现&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;自从出国来读书就更加无聊了，所以开始刷题了。十分感谢这些题，让我从完全不知道DFS，到逐渐理解DFS的内涵，再到这题的优化。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;https://zoj.pintia.cn/problem-sets/91827364500/problems/91827364507&quot;&gt;题目&lt;/a&gt;&lt;/h2&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:200px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/ZOJ1008/question.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;Question Cube&lt;/center&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:200px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/ZOJ1008/solution.png&quot; /&gt;&lt;/div&gt;

&lt;center&gt;Solution Cube&lt;/center&gt;

&lt;ol&gt;
  &lt;li&gt;题目关于一个大的正方形。&lt;/li&gt;
  &lt;li&gt;大的正方形由n*n个小的正方形组成。&lt;/li&gt;
  &lt;li&gt;每个正方向被分成了4块三角形，三角形上有各自的数字。&lt;/li&gt;
  &lt;li&gt;问能否通过排列这n*n个小正方形，使得所有三角形上的数字和其正对着的三角形相同。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;输入&quot;&gt;输入&lt;/h3&gt;

&lt;p&gt;第1行，每行的小正方形数。&lt;/p&gt;

&lt;p&gt;接下来的n行中，4个数分别是正方形内部“上，右，下，左”的三角形的值，&lt;/p&gt;

&lt;p&gt;0 &amp;lt;= n &amp;lt;= 5, n 为0时表示输入结束了。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2
5 9 1 4
4 4 5 6
6 8 5 4
0 4 4 3
2
1 1 1 1
2 2 2 2
3 3 3 3
4 4 4 4
0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;输出&quot;&gt;输出&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Game 1: Possible

Game 2: Impossible
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于每个游戏先输出 “Game”，再输出空格，再输出第几个游戏，再输出”:”,再输出空格，再对应输出”Possible”或者”Impossible”。&lt;/p&gt;

&lt;p&gt;每个游戏之间需要有一个空行。&lt;/p&gt;

&lt;h2 id=&quot;分析与第一次尝试&quot;&gt;分析与第一次尝试&lt;/h2&gt;

&lt;p&gt;&lt;del&gt;首先题目中没有说到正方形可以旋转，这降低了很多难度。&lt;/del&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;将图中的正方形逻辑是分成每个正方形自身，以及N个槽位。&lt;/li&gt;
  &lt;li&gt;对于每一个小正方形构成的大正方形虽然是一个二维的结构，但是因为二维数组去实现iterate和backtrack一方面容易越界，一方面在代码里需要多一层循环会大大降低可读性，而且难以去构思如何实现。所以把n*n(后文称N)个小正方形存到一位数组里，再用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%&lt;/code&gt;操作去处理会方便很多。 （使用一位数组存储小正方形（实际上是二维数组，因为每个小正方形还有4个三角形值需要存储））&lt;/li&gt;
  &lt;li&gt;要探寻可能性，所以要得到所有的小正方形的排布情况（即N个数的全排列），会得到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N!&lt;/code&gt;个排列。（找到全排列）&lt;/li&gt;
  &lt;li&gt;每个排列中的数 - 1为小正方形的编号，再对每个排列按照排列顺序将对应小正方放入第 1-N个槽中。（通过每个排列建立小正方形和位置的映射）&lt;/li&gt;
  &lt;li&gt;对每个排列的情况进行检验，检验每个正方形的上下左右的三角形是否和对应的三角形等值，如果出现全等，之后的便不再检验（可以通过Exception实现，也可以通过检测一些简单的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boolean flag&lt;/code&gt;来判断）。&lt;/li&gt;
&lt;/ol&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:700px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/ZOJ1008/Solution1.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;虽然我轻松地用DFS把全排列的方法给写了出来，但是结果却很现实，要么是时间超要么是内存超（绝大多数时候是时间超）。而且，我还并不知道是超了，以至于我根本就不知道该如何改进。&lt;/p&gt;

&lt;h2 id=&quot;优化&quot;&gt;优化&lt;/h2&gt;

&lt;p&gt;除了改用原生数组实现容器操作，很快我就发现了一些可以优化的空间。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;不需要比较上下左右，对于已经给出的特定排列左下开始，每个小正方形只需要比较上和右。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不需要把所有的排列都存起来，在已经全排列模块已经找到一个新的排列的情况下，可以直接检测。这样有两个好处：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;减少了排列的存储空间&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如果成功，可以直接进行下一个游戏的检测，省去了继续计算全排列的时间。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在录入具体三角形的迭代中，可以计算不正方形见一共存在的等值的三角形的对字数，当这个数小于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2*n&lt;/code&gt;对时，则一定不能完成游戏。 （在第一版优化中实现了该功能，因为“不同正方形”间的等值三角形比较难实现，代码又重构了，于是在后续的优化中就没有针对这个比较specific的情况写处理）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:700px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/ZOJ1008/Solution2.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;然而还是超，超得莫名其妙，而且什么信息也不给。我并不知道我是超了一点，还是超了几个量级，于是我开始苦恼了。&lt;/p&gt;

&lt;h2 id=&quot;继续优化&quot;&gt;继续优化&lt;/h2&gt;

&lt;p&gt;我开始在网络上寻找一些点拨，随便浏览一两篇文章。看到&lt;strong&gt;压缩与分类&lt;/strong&gt;，我像是突然间醒悟过来一样，其实这并不是“全排列”，而且绝大多数时候总是用全排列去处理问题是一种图方便的方式。因为，分类是在排列问题中总是可以做的一个步骤。&lt;/p&gt;

&lt;h3 id=&quot;如果有小正方形一样怎么办&quot;&gt;如果有小正方形一样怎么办？&lt;/h3&gt;

&lt;p&gt;当存在数目不等的一样的小正方形的时候，这个问题就从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1-N&lt;/code&gt;的排列变成了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a个1，b个2，.., x个N&lt;/code&gt;的排列，如果把他当作全排列去对待，那必然会在结果在出现的冗余的操作。&lt;/p&gt;

&lt;h3 id=&quot;重构&quot;&gt;重构&lt;/h3&gt;

&lt;p&gt;把原本的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;正方形容器&lt;/code&gt;拆分成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;小正方形类型容器&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;小正方形类型数量容器&lt;/code&gt;。全排列模块也相应的通过前面两个参数来控制迭代，从原本的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1-N) -&amp;gt; (2-N)-&amp;gt; ... -&amp;gt; N&lt;/code&gt;的单个参数控制的DFS变成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;先同类型不同数量DFS&lt;/code&gt;再&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;不同类型DFS&lt;/code&gt;的二维迭代方式。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:700px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/ZOJ1008/Solution3.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;然而，时间还是超了。&lt;/p&gt;

&lt;h2 id=&quot;永无止境的优化&quot;&gt;永无止境的优化&lt;/h2&gt;

&lt;h3 id=&quot;为什么还是超了&quot;&gt;为什么还是超了？&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;因为嵌套的循环太多!&lt;/strong&gt; 这是这直接原因，真正影响效率的从来都不是什么细枝末节的检查检查2个方向还是检查4个方向，整个程序最深的循环嵌套，才是需要被优化的地方。&lt;/p&gt;

&lt;p&gt;要么改变基础算法把嵌套层次减少，要么让不合规的操作&lt;strong&gt;尽快&lt;/strong&gt;地continue或者break。&lt;/p&gt;

&lt;p&gt;然后再反思一下之前的程序设计：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;循环最多的代码块很显然在排列的迭代&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果觉得通过降低基础的搜索算法来减少复杂度是困难的，那就应该尽快地continue或者break。（本质就是，检验操作应该在越浅层越好）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;之前的检验操作都是在一次排列完成后再操作的&lt;/strong&gt;，我们能把他尽可能的提到浅层吗？&lt;/p&gt;

    &lt;p&gt;不需要，因为可以一边搜索排列的结果，一边计算当下排列的元素的合法性。只需要，把原先的比较&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;右，上&lt;/code&gt;改成比较&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;左，下&lt;/code&gt;就行了，每次比较的都是已经深搜出来的元素。这样，在发现部分排列不合适的时候，就可以直接进入下一次排列的搜索。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:700px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/ZOJ1008/Solution4.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;于是，就Accepted啦！:D&lt;/p&gt;

&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;

&lt;script src=&quot;https://gist.github.com/eMous/5acf1e033378d3c685ccf829c29fa346.js&quot;&gt;&lt;/script&gt;

 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2020-03-30T00:00:00+08:00&quot;&gt;
                2020-03-30
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Mon, 30 Mar 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/03/30/ZOJ1008/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/03/30/ZOJ1008/</guid>
        
        <category>programming</category>
        
        <category>practice</category>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>自动批量登陆Tim</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#预备&quot; id=&quot;markdown-toc-预备&quot;&gt;预备&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#脚本&quot; id=&quot;markdown-toc-脚本&quot;&gt;脚本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于Tim只能自动登录一个账号，又或者设置最多3个关联账号（无法自动登录）。所以我决定自己实现多个Tim账号的自动登录。（使用Autohotkey）&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;预备&quot;&gt;预备&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;记住你要登陆的所有QQ号的密码。（或者在下方脚本里自己设置账号和（按下Tab再输入密码）密码）。&lt;/li&gt;
  &lt;li&gt;调试一下下方脚本的鼠标移动位置，确保它会停留在账号栏中。&lt;/li&gt;
  &lt;li&gt;修改QQ号成为你自己账号的前缀。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将脚本（或者快捷方式）移动到Startup文件夹。&lt;/p&gt;

    &lt;p&gt;C:\Users\你的用户名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;脚本&quot;&gt;脚本&lt;/h2&gt;

&lt;script src=&quot;https://gist.github.com/eMous/70df9702975595be8fa46e2761be2945.js&quot;&gt;&lt;/script&gt;

 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-05-26T00:00:00+08:00&quot;&gt;
                2019-05-26
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Sun, 26 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/26/AutoLoginTim/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/26/AutoLoginTim/</guid>
        
        <category>tools</category>
        
        <category>Autohotkey</category>
        
        
        <category>自动化</category>
        
      </item>
    
      <item>
        <title>数据结构（八）：图</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#定义&quot; id=&quot;markdown-toc-定义&quot;&gt;定义&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;图的相关知识。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;

 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-05-22T00:00:00+08:00&quot;&gt;
                2019-05-22
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Wed, 22 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/22/DataStructure_Graph/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/22/DataStructure_Graph/</guid>
        
        
        <category>数据结构</category>
        
      </item>
    
      <item>
        <title>数据结构（七）：树</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#定义&quot; id=&quot;markdown-toc-定义&quot;&gt;定义&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#性质&quot; id=&quot;markdown-toc-性质&quot;&gt;性质&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#二叉树&quot; id=&quot;markdown-toc-二叉树&quot;&gt;二叉树&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#存储结构&quot; id=&quot;markdown-toc-存储结构&quot;&gt;存储结构&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#顺序存储&quot; id=&quot;markdown-toc-顺序存储&quot;&gt;顺序存储&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#链式存储&quot; id=&quot;markdown-toc-链式存储&quot;&gt;链式存储&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#遍历&quot; id=&quot;markdown-toc-遍历&quot;&gt;遍历&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#递归遍历&quot; id=&quot;markdown-toc-递归遍历&quot;&gt;递归遍历&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#表达式的表示&quot; id=&quot;markdown-toc-表达式的表示&quot;&gt;表达式的表示&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#非递归遍历&quot; id=&quot;markdown-toc-非递归遍历&quot;&gt;非递归遍历&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#线索二叉树&quot; id=&quot;markdown-toc-线索二叉树&quot;&gt;线索二叉树&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#线索化&quot; id=&quot;markdown-toc-线索化&quot;&gt;线索化&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#树和森林&quot; id=&quot;markdown-toc-树和森林&quot;&gt;树和森林&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#存储结构-1&quot; id=&quot;markdown-toc-存储结构-1&quot;&gt;存储结构&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#双亲表示法&quot; id=&quot;markdown-toc-双亲表示法&quot;&gt;双亲表示法&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#孩子表示法&quot; id=&quot;markdown-toc-孩子表示法&quot;&gt;孩子表示法&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#森林和二叉树互换&quot; id=&quot;markdown-toc-森林和二叉树互换&quot;&gt;森林和二叉树互换&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#遍历森林&quot; id=&quot;markdown-toc-遍历森林&quot;&gt;遍历森林&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#应用&quot; id=&quot;markdown-toc-应用&quot;&gt;应用&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#等价问题&quot; id=&quot;markdown-toc-等价问题&quot;&gt;等价问题&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#赫夫曼&quot; id=&quot;markdown-toc-赫夫曼&quot;&gt;赫夫曼&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#最优二叉树赫夫曼树&quot; id=&quot;markdown-toc-最优二叉树赫夫曼树&quot;&gt;最优二叉树（赫夫曼树）&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#赫夫曼编码&quot; id=&quot;markdown-toc-赫夫曼编码&quot;&gt;赫夫曼编码&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#赫夫曼编码的实现&quot; id=&quot;markdown-toc-赫夫曼编码的实现&quot;&gt;赫夫曼编码的实现&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/Tree/cover.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;树的相关知识。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:200px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/Tree/1.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;子树&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;根节点紧挨着的每个节点作为根节点构成的树。图中A有3个子树（{BEKLF},{CG},{DHMIJ}）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结点的度&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;子树的个数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;树的度&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;树内所有结点的度的最大值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;深度&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;树中的最大层数。该图代表的树的深度为4。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;祖先&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;根节点到该节点分支上所有的结点。图中E的祖先为(B,A)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;子孙&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;以某节点为根的子树中的任意结点（除去自身），都是该节点的子孙。图中E的子孙为(K,L)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;堂兄弟&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;父（双亲）结点的所有兄弟结点的所有孩子。图中E的堂兄弟为（G,H,I,J）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;有/无序树&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;树中结点的各子树的左右排列是可以/不可以互换的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;森林&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;m棵互不相交的树的集合。对于树中的每一个结点而言，其子树的集合构成了森林。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二叉树&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;树的度为2的有序树。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;完全二叉树&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;二叉树中的结点和满二叉树的结点一一对应。（结点从左往右一个接一个不空位置。）&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:200px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/Tree/2.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;正则二叉树&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;不包含度为1的结点的二叉树。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;赫夫曼树&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;带权路径长度最小的二叉树。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相似树&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;形态同，元素值不一定同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;等价树&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;相似且元素值都相同。&lt;/p&gt;

&lt;h2 id=&quot;性质&quot;&gt;性质&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;二叉树的第$i$层最多$2^{i-1}$个结点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;深度为$k$的二叉树最多$2^k-1$个结点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;任何一个二叉树，如果其叶子（终端）结点数为$n_0$，度为$2$的结点数为$n_2$，则$n_0=n_2+1$。&lt;/p&gt;

    &lt;p&gt;$n=n_0+n_1+n_2$&lt;/p&gt;

    &lt;p&gt;$n = B+1$ （除根结点外，每个结点都是由一个分支进入）&lt;/p&gt;

    &lt;p&gt;$B=n_1+2n_2$（每个分支要么由度为2的结点射出要么由度 为1的结点射出）&lt;/p&gt;

    &lt;p&gt;（叶子结点的个数是度为2的结点的个数 + 1）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;具有$n$个结点的&lt;strong&gt;完全二叉树&lt;/strong&gt;的深度为$\lfloor \log_2n \rfloor + 1$。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于有$n$个结点的完全二叉树（从左往右）的第$i(1\leqslant i \leqslant n)$个结点：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;$i$为1，结点为根，无父结点。&lt;/li&gt;
      &lt;li&gt;其余任何结点，父结点为第$\lfloor i/2 \rfloor$。&lt;/li&gt;
      &lt;li&gt;若$2i &amp;gt; n $则该结点没有左孩子结点。&lt;/li&gt;
      &lt;li&gt;若$2i +1&amp;gt; n $则该结点没有右孩子结点。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$n$个叶子结点的正则二叉树一共有$2n-1$个结点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$n$个结点的不相似的二叉树有$\frac{1}{n+1} C_{2 n}^{n}$个。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$n$个结点的不相似的树的个数和$n-1$个不相似结点的二叉树的个数相同。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二叉树&quot;&gt;二叉树&lt;/h2&gt;

&lt;h3 id=&quot;存储结构&quot;&gt;存储结构&lt;/h3&gt;

&lt;h4 id=&quot;顺序存储&quot;&gt;顺序存储&lt;/h4&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define MAX_TREE_SIZE 100					// 二叉树的最大结点数
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TElemType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SqBiTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_TREE_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// 0号单元存储根结点&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;SqBiTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:200px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/Tree/3.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;把&lt;strong&gt;完全二叉树中的结点编&lt;/strong&gt;号和&lt;strong&gt;数组的索引编号&lt;/strong&gt;对应。数组中的元素类型需要提供功能以标识元素是否存在（图中以0假定不存在）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;顺序存储结构仅适用于存储完全二叉树&lt;/strong&gt;，因为最坏的情况下，一个深度为$k$且仅有$k$个结点的单支树却需要长度为$2^k-1$的一维数组。&lt;/p&gt;

&lt;h4 id=&quot;链式存储&quot;&gt;链式存储&lt;/h4&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:200px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/Tree/4.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;链式存储包含两种形式，含有两个指针域的结点结构——二叉链表（只指向孩子结点）和含有三个指针域的结点结构——三叉链表（指向孩子结点和父结点）。&lt;/p&gt;

&lt;p&gt;含有$n$个结点的二叉链表中有$n+1$个空域，可以利用这些空域存储额外的信息构建——&lt;strong&gt;线索链表&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;遍历&quot;&gt;遍历&lt;/h3&gt;

&lt;p&gt;对于二叉树的遍历&lt;strong&gt;按照对于根节点的访问顺序&lt;/strong&gt;分为三个方式（都是从左到右）：先序遍历，中序遍历和后序遍历。&lt;/p&gt;

&lt;p&gt;先序遍历&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;访问根节点。&lt;/li&gt;
  &lt;li&gt;先序遍历左子树。&lt;/li&gt;
  &lt;li&gt;先序遍历右子树。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;中序遍历&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;中序遍历左子树。&lt;/li&gt;
  &lt;li&gt;访问根节点。&lt;/li&gt;
  &lt;li&gt;中序遍历右子树。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;后序遍历&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;后序遍历左子树。&lt;/li&gt;
  &lt;li&gt;后序遍历右子树。&lt;/li&gt;
  &lt;li&gt;访问根节点。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;递归遍历&quot;&gt;递归遍历&lt;/h4&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PreOrderTraverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BiTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TElemType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 先序遍历二叉树的递归算法&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;PreOrderTraverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;PreOrderTraverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;表达式的表示&quot;&gt;表达式的表示&lt;/h4&gt;

&lt;p&gt;若表达式为数或简单变量，则对应二叉树中仅有一个根结点，其数据域存放该表达式信息；若表达式=（第一操作数）（运算符）（第二操作数），则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根节点的数据域存放运算符（若为一元运算符则左子树为空）。操作数本身又为表达式。&lt;/p&gt;

&lt;p&gt;则对于表达式$a+b *(c-d)-e / f$，可以得到其对应的二叉树为下图。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:200px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/Tree/5.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;先序遍历得到序列$-+a * b-c d / e f$（前缀表示，波兰式）。&lt;/p&gt;

&lt;p&gt;中序遍历得到序列$a+b * c-d-e / f$（中缀表示）。&lt;/p&gt;

&lt;p&gt;后序遍历得到序列$a b c d-*+e f-$（后缀表示，逆波兰式）。&lt;/p&gt;

&lt;h4 id=&quot;非递归遍历&quot;&gt;非递归遍历&lt;/h4&gt;

&lt;p&gt;以中序遍历为例，对其递归遍历算法实际操作过程可以做如下分析。&lt;/p&gt;

&lt;p&gt;将根结点（不为空）压入栈中&lt;/p&gt;

&lt;p&gt;循环直到（栈为空栈）{&lt;/p&gt;

&lt;p&gt;​	循环直到（栈顶为空）{&lt;/p&gt;

&lt;p&gt;​		压入栈顶结点的左子结点。&lt;/p&gt;

&lt;p&gt;​	}&lt;/p&gt;

&lt;p&gt;​	// 当前栈顶一定为空 （可能是访问左结点导致的空 也可能是 访问右结点导致的空）&lt;/p&gt;

&lt;p&gt;​	出栈。&lt;/p&gt;

&lt;p&gt;​	// 当前栈顶可能时单独的左子结点 也可能是 单独的右子结点 也可能 从根结点退出&lt;/p&gt;

&lt;p&gt;​	如果（栈非空）{&lt;/p&gt;

&lt;p&gt;​		（栈顶结点一定不存在左子结点了）&lt;/p&gt;

&lt;p&gt;​		访问栈顶结点。&lt;/p&gt;

&lt;p&gt;​		退栈。&lt;/p&gt;

&lt;p&gt;​		压入该结点的右子结点。&lt;/p&gt;

&lt;p&gt;​	}&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InOrderTravers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BiTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TElemType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 二叉链表 中序遍历 非递归&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;InitStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;				&lt;span class=&quot;c1&quot;&gt;// 压入根指针&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StackEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 只要栈中还有没有处理完的结点&lt;/span&gt;
   		&lt;span class=&quot;c1&quot;&gt;// 如果当前栈顶不是空元素，尽可能的压入该元素的左结点&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetTop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
       	&lt;span class=&quot;c1&quot;&gt;// 脱去栈顶的指针&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
        &lt;span class=&quot;c1&quot;&gt;// 如果栈还没有处理完&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StackEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 当前栈顶元素一定不存在左子结点了，所以按照中序遍历直接可以访问栈顶元素了。&lt;/span&gt;
        	&lt;span class=&quot;n&quot;&gt;Pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 访问当前栈顶结点，并退栈。&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// 压入该结点的右子结点。&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InOrderTravers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BiTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TElemType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 另一个实现&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;InitStack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// 只要当下待处理的结点不为空，或者栈中还有结点&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StackEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 如果当前有待处理结点，将其左子结点依次压入栈中，并重置待处理结点&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 若待处理结点被设置为空（说明待处理结点的最左子结点已经压栈到位）&lt;/span&gt;
            
            &lt;span class=&quot;n&quot;&gt;Pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 最左结点处理完毕（该结点一定不存在更左结点），所以将其右子结点设置成待处理结点（此时没有压栈）。&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;时间复杂度为$O(n)$，空间复杂度最坏情况也为$O(n)$。&lt;/p&gt;

&lt;h3 id=&quot;线索二叉树&quot;&gt;线索二叉树&lt;/h3&gt;

&lt;p&gt;通过给不存在子结点的结点，提供相关的前驱后继信息（放置于原本为空的指针域）可以加速二叉树的遍历。但是需要额外的提供两个标志域，用于标识该信息的类型是&lt;strong&gt;单纯的子结点&lt;/strong&gt;还是用于&lt;strong&gt;表示前驱后继的线索&lt;/strong&gt;。其节点结构与标志含义如下图所示：&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/Tree/6.png&quot; /&gt;&lt;/div&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:100px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/Tree/7.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;线索化&lt;/strong&gt;指对二叉树以某种次序遍历使其变成线索二叉树的过程。下图为一个中序线索链表实例，虚线为线索，实现为实际子结点。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:200px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/Tree/5.png&quot; /&gt;&lt;/div&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:350px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/Tree/8.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;虽然线索二叉树的遍历过程也是$O(n)$，但其常数因子却比之前的算法的常数因子小得多，并且整个过程不需要使用&lt;strong&gt;栈&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 二叉树的二叉线索存储&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Link&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PointerTag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Link == 0, Thread == 1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitThrNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TElemType&lt;/span&gt; 				&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitThrNode&lt;/span&gt; 		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PointerTag&lt;/span&gt;				&lt;span class=&quot;n&quot;&gt;LTag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RTag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// 标志&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BiThrNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitThrTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通常，&lt;strong&gt;在二叉树的线索链表上也会添加一个头结点&lt;/strong&gt;，并令其lchild域的指针指向二叉树的&lt;strong&gt;根结点&lt;/strong&gt;，rchild域指向中序&lt;strong&gt;遍历的最后一个结点&lt;/strong&gt;。同时，令第一个结点的lchild和最后一个结点的rchild指向头结点。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InOrderTraverse_Thr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BiThrTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TElemType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 对中序二叉线索树 的 遍历&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 第一个结点&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// p == T 时则遍历完成，T是最后一个结点的后继&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LTag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Link&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 访问最左叶结点&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RTag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 访问之前那个最左叶节点的 所有 不包含 右子结点的 祖先结点&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 直到访问包含右子结点的一个&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 切换到那个右子结点&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// 继续找最左的叶节点&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;线索化&quot;&gt;线索化&lt;/h4&gt;

&lt;p&gt;线索化的过程本质上就是在遍历的过程中修改空指针的过程。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pre&lt;/code&gt;指针用于记录遍历期间的，刚刚访问过的（上一个）结点，即前驱。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InOrderThreading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BiThrTree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BiThrTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 中序遍历二叉树T，并将其中序线索化，Thrt指向头结点。&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thrt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BiThrTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BiThrNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OVERFLOW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 设置头节点&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Thrt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LTag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Link&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thrt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RTag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Thrt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 初始化（在后面会正确设置）&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thrt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lchild&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 若T为空，则只有一个头结点。 (从而使得不会命中下面行数的第一个 if(!pre-&amp;gt;rchild)) &lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thrt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lchild&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 设置 lchild，pre&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;InThreading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// 此时 pre 是最后一个结点&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RTag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thrt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InThreading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BiThrTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 和中序遍历 差不多&lt;/span&gt;
       
        &lt;span class=&quot;c1&quot;&gt;// 左子树线索化&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;InThreading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 如果他是最左子树，第一个被遍历到的结点，正好可以把lchild设置成Thrt&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LTag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lchild&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RTag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 更新pre&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pre&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// 右子树线索化&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;InThreading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;树和森林&quot;&gt;树和森林&lt;/h2&gt;

&lt;h3 id=&quot;存储结构-1&quot;&gt;存储结构&lt;/h3&gt;

&lt;h4 id=&quot;双亲表示法&quot;&gt;双亲表示法&lt;/h4&gt;

&lt;p&gt;双亲表示法要求每个结点记录其父结点（因为每个树的结点只有一个所以这个数据域的长度是固定的），所有的结点存储在一个连续的存储空间中。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 树的双亲存储表示&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define MAX_TREE_SIZE 100
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TElemType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// 双亲位置域&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PTNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PTNode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_TREE_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 		&lt;span class=&quot;c1&quot;&gt;// 结点数&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:350px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/Tree/9.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;这种结构的好处在于对于特定的结点，可以在常量时间内寻找到父结点。并且反复调用PARENT可以快速的得到根结点。但是求孩子结点的时候却要遍历整个结构。&lt;/p&gt;

&lt;h4 id=&quot;孩子表示法&quot;&gt;孩子表示法&lt;/h4&gt;

&lt;p&gt;由于每个结点的孩子结点数目是不不确定的，因此需要用多重链表，即每个结点有多个指针域。&lt;/p&gt;

&lt;p&gt;多重链表又有两种形式:&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/Tree/10.png&quot; /&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;每个结点的指针个数和树的度相同（方便但浪费空间）&lt;/li&gt;
  &lt;li&gt;每个结点的指针个数和该结点的度相同，并标识出该节点的度（节省空间但操作不便）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;再或者使用一个类似于单链表的形式将孩子结点串起来，n个结点就有n个孩子线性链表。n个结点指针又组成一个线性表，为了方便查找可以使用顺序存储结构。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 树的孩子链表存储表示&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CTNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// 孩子结点&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; 			&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CTNode&lt;/span&gt; 	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ChildPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// 被包装的结点&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TElemType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ChildPtr&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;firstchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// 孩子链表头指针&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CTBox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CTBox&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_TREE_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// 结点数和根的位置 &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果在结点处附带父节点信息，同样可以实现父结点的快速查找。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/Tree/11.png&quot; /&gt;&lt;/div&gt;

&lt;h3 id=&quot;森林和二叉树互换&quot;&gt;森林和二叉树互换&lt;/h3&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/Tree/12.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;右子树就是兄弟，左子树就是第一个子树。&lt;/p&gt;

&lt;h3 id=&quot;遍历森林&quot;&gt;遍历森林&lt;/h3&gt;

&lt;p&gt;先化成对应二叉树，再遍历。&lt;/p&gt;

&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;

&lt;h3 id=&quot;等价问题&quot;&gt;等价问题&lt;/h3&gt;

&lt;p&gt;对于已知的m个偶对，构建等价类。本质上就是使用树来构建&lt;strong&gt;并查集&lt;/strong&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;构造每个单一元素为根的单结点树的森林。&lt;strong&gt;并且该森林中的每个树的每个结点都指向其父结点&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;重复读入偶对，分别判断x,y所在的子集（树），若相同则下一对。若不同，则将$S_j$复制并入$S_i$。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以重要的操作只有两个，&lt;strong&gt;查找某个元素的所在树的根结点&lt;/strong&gt; 和 &lt;strong&gt;将树和树合并&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// MFSet使用树的双亲表存储表示 （它其实是一个森林）&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;find_mfset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MFSet&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 找森林（集合）S中，i结点所在的树的根结点(根结点的parent &amp;lt;= 0(应该是0))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;merge_mfset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MFSet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 将j结点为根的树 并 到i结点为根的树&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find_mfset&lt;/code&gt;的复杂度为$O(深度)$,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge_mfset&lt;/code&gt;的复杂度为$O(1)$。一个森林n个结点，需要n-1次查并操作，所以复杂度为$O(n^2)$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;若每次合并的时候都是少结点的集合像多的集合合并（&lt;del&gt;因为少结点的集合 要么不给多结点的集合增加更多的深度，要么最多只有少集合的最大深度&lt;/del&gt;），其深度不会超过$\lfloor \log_2n \rfloor + 1$，从而复杂度捡到少$O(nlogn)$。 根结点的parent为负数，是其包含的所有结点的计数的负数。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mix_mfset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MFSet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// i的比j的少，因为约定是负数&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;再优化&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fix_mfset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MFSet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 确定i所在的自己，并将从i至根路径上所有结点都变成根的孩子结点&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其复杂度为$O(na(n))$，对于通常正整数n，$a(n) &amp;lt;= 4$。&lt;/p&gt;

&lt;h3 id=&quot;赫夫曼&quot;&gt;赫夫曼&lt;/h3&gt;

&lt;h4 id=&quot;最优二叉树赫夫曼树&quot;&gt;最优二叉树（赫夫曼树）&lt;/h4&gt;

&lt;p&gt;赫夫曼树的构造方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;每个带权结点看成独立的树，共n个结点（独立的树）在集合S中。&lt;/li&gt;
  &lt;li&gt;权值最小的两个树构成新的二叉树
    &lt;ol&gt;
      &lt;li&gt;在S中去除这两个结点&lt;/li&gt;
      &lt;li&gt;生成的二叉树的根结点的权值为两结点之和&lt;/li&gt;
      &lt;li&gt;生成的二叉树的根结点加入到集合S中&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;重复1,2&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;赫夫曼编码&quot;&gt;赫夫曼编码&lt;/h4&gt;

&lt;p&gt;对于需要传输的信息，可以使用二进制的方式来&lt;strong&gt;辨别&lt;/strong&gt;传输信息中的&lt;strong&gt;基础字符&lt;/strong&gt;（例如’ABCAB’中的’A’，’B’，’C’）。&lt;/p&gt;

&lt;p&gt;对于不同元素的编码有两个原则：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不存在二义性&lt;/li&gt;
  &lt;li&gt;总长越小越好（出现频率低的字符用更小的串）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不存在二义性的编码只映射一个字符的二进制串被称作&lt;strong&gt;前缀码&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;为满足第一个原则，最自然的方法是使用二叉树，将左分支设置为0，又分支设置为1。再约定从上到下组成的串，必定只能映射到一个叶子结点（字符元素）因此不会存在二义性。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:250px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/Tree/13.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;对于第二个原则，则可以正好对应的二叉树是赫夫曼树。&lt;/p&gt;

&lt;h5 id=&quot;赫夫曼编码的实现&quot;&gt;赫夫曼编码的实现&lt;/h5&gt;

&lt;p&gt;因为赫夫曼树是正则二叉树所以n个叶子结点的话，有2n-1个结点。所以存储在一个2n-1长度的数组里，n个叶子结点用来代表n个字符。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 赫夫曼树和赫夫曼编码的存储表示&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HTNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HuffmanTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 赫夫曼树&lt;/span&gt;
   
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HuffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 赫夫曼编码表&lt;/span&gt;
   
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;HuffmanCoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HuffmanTree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HuffmanCode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
 	&lt;span class=&quot;c1&quot;&gt;// n 为n个字符， w 为每个字符的权值&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HuffmanTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HTNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;	 &lt;span class=&quot;c1&quot;&gt;// 申请空间，因为n是动态的所以动态申请，第0号位不使用&lt;/span&gt;
       
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 前n个结点为叶子结点&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 初始化叶子结点的权值到对应的字符频率&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 构建赫夫曼树&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 在HT[1..i-1]中选择parent为0且weight最小的两个结点，其序号分别为s1,s2&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lchild&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
       
    &lt;span class=&quot;c1&quot;&gt;// 从叶子到根逆向求每个字符的赫夫曼编码&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 分配n个字符编码的头指针向量&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;HC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HuffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;	
    &lt;span class=&quot;c1&quot;&gt;// 分配求单个字符编码的工作空间（单个字符的 最大 n，并不是最终串长）,并且这个空间可以每个字符循环利用&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;`\&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 从叶子结点的上一个结点开始一个一个判断是父结点的左子结点还是右子结点&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 然后从串的尾部开始设置&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lchild&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 最中单个字符对应的串长确定&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;HC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mallock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同样也可以从根结点出发求得赫夫曼编码。 不论是从叶子还是从根计算赫夫曼编码，遍历的顺序（选择的字符的顺序）都是 左到底，右，继续做到底，右…。发现的所有叶子结点的顺序。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:250px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/Tree/14.png&quot; /&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 无栈 非递归 遍历赫夫曼树，求赫夫曼编码&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;HC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HuffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 根据上述的构造 m 一定是根结点&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cdlen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 初始化每个结点的访问标志&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 如果这个结点还没有被处理过&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 设置本结点为已经初次处理，先不管到底有没有左子结点&lt;/span&gt;
    	&lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 如果该结点有左子结点，切换待处理结点，且在工作空间补充对应的字符位0&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lchild&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cdlen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 若它没有左子结点，又没有右子结点，那它必定是叶子结点&lt;/span&gt;
            
            &lt;span class=&quot;c1&quot;&gt;// 这是的单个字符的赫夫曼码就处理完毕&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;HC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cdlen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cdlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 如果当前结点已经处理过了 左子结点 &lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// 将其状态位设置为已经处理过了 右子结点，先不管到底有没有右子结点&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 如果它存在右子结点，切换待处理结点，且在工作空间补充对应的字符位1&lt;/span&gt;
      		&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rchild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cdlen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 如果待处理结点 已经处理完毕了右子结点&lt;/span&gt;
            
            &lt;span class=&quot;c1&quot;&gt;// 就让待处理结点回退到上一层（去继续处理右子结点）&lt;/span&gt;
            
            &lt;span class=&quot;c1&quot;&gt;// 我认为这句置空没有意义，因为不会再回来处理这个结点了，这个结点下的所有结点都处理完毕了，仅仅是设置成和初始化一样的值罢了&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            
            &lt;span class=&quot;c1&quot;&gt;// 待处理接待结点回溯到上一层结点，编码长度减1&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cdlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-05-20T00:00:00+08:00&quot;&gt;
                2019-05-20
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Mon, 20 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/20/DataStructure_Tree/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/20/DataStructure_Tree/</guid>
        
        
        <category>数据结构</category>
        
      </item>
    
      <item>
        <title>算法（三）：稀疏矩阵的乘法</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#数据结构&quot; id=&quot;markdown-toc-数据结构&quot;&gt;数据结构&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#算法&quot; id=&quot;markdown-toc-算法&quot;&gt;算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;数据结构&quot;&gt;数据结构&lt;/h2&gt;

&lt;p&gt;回顾上次我们描述&lt;strong&gt;&lt;a href=&quot;/2019/05/15/QuickMatrixTrans/&quot;&gt;稀疏矩阵转置算法&lt;/a&gt;&lt;/strong&gt;时描述稀疏矩阵的数据结构。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;# define MAXSIZE 12500          // 最大的非零元素个数
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;               		&lt;span class=&quot;c1&quot;&gt;// 分别表示非零元素的行下标和列下标&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ElemType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                	&lt;span class=&quot;c1&quot;&gt;// 元素值&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Triple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Triple&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAXSIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;  	&lt;span class=&quot;c1&quot;&gt;// 所有的非零元素， data[0]弃用&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// 矩阵的行数、列数和总共的非零元素个数&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TSMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以发现这个样的数据结构无法&lt;strong&gt;随机地定位任意一行非零元&lt;/strong&gt;，因此为了方便做乘法，需要重构数据结构辅助创建一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;带有每行首个非零元位置的数组&lt;/code&gt;。这类&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;带有行链接信息&lt;/code&gt;的三元组表又被称作&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;行逻辑链接的顺序表&lt;/code&gt;如下：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Triple&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAXSIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;  	&lt;span class=&quot;c1&quot;&gt;// 所有的非零元素， data[0]弃用&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rpos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAXRC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// 各行第一个非零元素的位置表&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// 矩阵的行数、列数和总共的非零元素个数&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TSMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;算法&quot;&gt;算法&lt;/h2&gt;

&lt;p&gt;对于传统的矩阵相乘\(Q=M\times N\)，其中\(M\)为\(m_1\times n_1\)矩阵，\(N\)为\(m_2\times n_2\)矩阵，若\(n_1 = m_2 = K\)，则有：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 左矩阵的每一行&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
       &lt;span class=&quot;c1&quot;&gt;// 右矩阵的每一列&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 左矩阵的列数 = 右矩阵的行数&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 对于左矩阵特定行 和 右矩阵特定列 元素逐一相乘再求和&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该算法的时间复杂度为\(O(m_1 \times K \times n2)\)对于三元组表作为存储结构的时候上述的运算不能直接套用，可以做出如下分析：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;乘积矩阵\(Q\)中元素的表示方式为：&lt;/p&gt;

\[\boldsymbol{Q}(i, j)=\sum_{k=1}^{K} M(i, k) \times N(k, j)
\quad
\begin{array}{}
1 \leqslant i \leqslant m_{1}  \\ 
1 \leqslant j \leqslant n_{2} 
\end{array}\]
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;0和任何数相乘都为0，因此上述算法中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M[i][k] * N[k][j]&lt;/code&gt;中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M[i][k]&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N[k][j]&lt;/code&gt;都必须为非0的项。&lt;/p&gt;

    &lt;p&gt;因此只需要确保&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M.data[each_p].j = N.data[each_q].i&lt;/code&gt;&lt;/strong&gt;匹配的元素才进行运算。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M.data[p].j = N.data[q].i&lt;/code&gt;，计算得到的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M.data[p].e * N.data[q].e&lt;/code&gt;也只是目标矩阵的某个元的其中一部分，真正的元还需要累加这些结果，因此需要一个&lt;strong&gt;累加器&lt;/strong&gt;来存储结果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;虽然\(M\)和\(N\)都是稀疏矩阵，但是结果未必是稀疏矩阵。同时，\(Q\)的元素是否是非零元只有在累加完毕后才能得知。&lt;strong&gt;由于\(Q\)中元素的行号和\(M\)中元素的行号一致，且\(M\)中元素的排列是以M的行序为主序的&lt;/strong&gt;，所以对\(Q\)进行计算的时候可以对\(Q\)进行逐行处理，先求得中间结果（&lt;strong&gt;\(Q\)的一行&lt;/strong&gt;），再压缩到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Q.data&lt;/code&gt;中去。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:400px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/RLSMatrix/RLSMatrix_multi.gif&quot; /&gt;&lt;/div&gt;

&lt;p&gt;具体思路如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Q初始化
if(M.tu * N.tu != 0){
	for(M的每一行arow{
		累加器清0
		
		计算Q中第arow行的N.nu个结果存入累加器
		
		将累加器中的非零元存入 Q.data
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体算法如下:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MultSMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RLSMatrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RLSMatrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RLSMatrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 初始化Q&lt;/span&gt;
   	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 确保不能直接得出0矩阵的结果&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arrow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 处理 M 的每一行&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 当前行的各元素的累加器（数组长度为M.nu,最后ctemp中将为Q的第arow行的所有元素值）&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ctemp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Q的每一行的第一个非0元素，都会等于目前Q的所有元素个数 + 1 （因为Q是行主序的）&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rpos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rpos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rpos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 遍历M当前行的每一个非零元素（列）&lt;/span&gt;
                
                &lt;span class=&quot;c1&quot;&gt;// 直接含义：获取当前元素的列号&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 隐藏含义：获取N中对应元素的行号&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;brow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
                
                &lt;span class=&quot;c1&quot;&gt;// t为 N中对应行的最后一个元素的位置 + 1 （从而可以遍历N中对应的行，使得 累加器的的元素（列）都能增加，直到M当前行中的最后一个元素被遍历，累加器才全部构造好Q第一行的元素。）&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;brow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rpos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;brow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rpos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;brow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// 乘积元素在Q中的列号&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;ccol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// 累加每一列的乘积和&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;ctemp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ccol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 这一行的结果已经计算出。&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 压缩这一行到Q中。&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ccol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ccol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ccol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctemp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ccol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAXSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ccol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctemp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ccol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]};&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;分析上述算法可得，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctemp&lt;/code&gt;初始化的时间复杂度为\(O(M.mu \times N.nu)\)(初始化应该就是置空的意思，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctemp&lt;/code&gt;的元素个数是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N.nu&lt;/code&gt;)。求\(Q\)的所有非零元的时间复杂度为\(O(M.mu \times N.tu/N.mu)\)(\(N.tu/N.mu\)就是平均每行的元素个数)，进行压缩的时间复杂度为\(O(M.mu \times N.nu)\)。因此，总复杂度是\(O(M.mu \times N.nu + M.tu \times N.tu/N.mu)\)。&lt;/p&gt;

&lt;p&gt;当\(M\)是一个\(m\)行\(n\)列的稀疏矩阵，\(N\)是一个$n$行$p$列的稀疏矩阵。则$M$中的非零元素个数为$\mathrm{M} . \mathrm{tu}=\delta_{\mathrm{M}} \times \mathrm{m} \times \mathrm{n}$，$N$中的非零元素个数为$\mathrm{N} . \mathrm{tu}=\delta_{\mathrm{N}} \times \mathrm{n} \times \mathrm{p}$。此时算法总体的时间复杂度为$O(m \times p \times (1 + n\delta_{\mathrm{M}}\delta_{\mathrm{N}}))$，当$\delta_{\mathrm{M}} &amp;lt; 0.05$和$\delta_{\mathrm{N}} &amp;lt; 0.05$及$n &amp;lt; 1000$时就相当于$O(m \times p)$。&lt;/p&gt;

 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-05-16T00:00:00+08:00&quot;&gt;
                2019-05-16
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Thu, 16 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/16/MatrixMulti/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/16/MatrixMulti/</guid>
        
        <category>数据结构</category>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>数据结构（六）：广义表</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#定义&quot; id=&quot;markdown-toc-定义&quot;&gt;定义&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#存储结构&quot; id=&quot;markdown-toc-存储结构&quot;&gt;存储结构&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#头尾链表存储表示&quot; id=&quot;markdown-toc-头尾链表存储表示&quot;&gt;头尾链表存储表示&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#扩展线性链表存储表示&quot; id=&quot;markdown-toc-扩展线性链表存储表示&quot;&gt;扩展线性链表存储表示&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#m元多项式的表示&quot; id=&quot;markdown-toc-m元多项式的表示&quot;&gt;$m$元多项式的表示&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#广义表的递归算法&quot; id=&quot;markdown-toc-广义表的递归算法&quot;&gt;广义表的递归算法&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#求广义表的深度&quot; id=&quot;markdown-toc-求广义表的深度&quot;&gt;求广义表的深度&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#分析&quot; id=&quot;markdown-toc-分析&quot;&gt;分析&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#广义表的复制&quot; id=&quot;markdown-toc-广义表的复制&quot;&gt;广义表的复制&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#基于字符串创建广义表&quot; id=&quot;markdown-toc-基于字符串创建广义表&quot;&gt;基于字符串创建广义表&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相比于线性表，广义表基于递归定义，可以将广义表本身作为结点存储在其元素中从而体现出更灵活的且宽泛的使用性。虽然，抽象数据类型——数组，也可以提供这类似的宽泛的数据储存功能，但它的长度和维度必须是定义时确定的，而广义表基于递归定义，可在使用时随时扩充删减元素。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;

&lt;p&gt;广义表时线性表的推广，也可以被称作&lt;strong&gt;列表&lt;/strong&gt;（List）。最为常见的广义表的应用就是Lisp语言，其源程序本身就是一系列广义表。&lt;/p&gt;

&lt;p&gt;广义表一般记作：$LS = (a_1,a_2,…,a_n)$。&lt;/p&gt;

&lt;p&gt;其中，LS为广义表的名称，n为其长度。与线性表不同的地方在于，&lt;strong&gt;$a_i$可以是单个元素也可以是广义表&lt;/strong&gt;，它们分别成为广义表LS的&lt;strong&gt;原子&lt;/strong&gt;和&lt;strong&gt;子表&lt;/strong&gt;。习惯上，大写字母用来表示广义表的名称，小写字母用来表示原子。&lt;/p&gt;

&lt;p&gt;当广义表LS非空时，第一个元素$a_1$为LS的表头(Head)，&lt;strong&gt;其余元素组成的表$(a_2,a_3,…,a_n)$&lt;/strong&gt;是LS的表尾(Tail)。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$A = ()$ ， A是一个空表，它的长度为0。&lt;/li&gt;
  &lt;li&gt;$B = (e)$，B是一个只包含一个原子$e$的表，它的长度为1。&lt;/li&gt;
  &lt;li&gt;$C = (a,(b,c,d))$，C的长度为2，元素分别为原子$a$和子表$(b,c,d)$。&lt;/li&gt;
  &lt;li&gt;$D = (A,B,C)$，D的长度是3，元素分别为A,B,C一共3个子表。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$GetHead(D) = A  \qquad  GetTail(D) = (B,C)$&lt;/p&gt;

&lt;h2 id=&quot;存储结构&quot;&gt;存储结构&lt;/h2&gt;

&lt;p&gt;广义表的数据元素具有不同的结构，因此难以使用顺序存储结构表示，通常使用链式存储结构表示，主要有两种方式。&lt;/p&gt;

&lt;h3 id=&quot;头尾链表存储表示&quot;&gt;头尾链表存储表示&lt;/h3&gt;

&lt;p&gt;由于数据元素既可能是原子又可能是广义表，所以需要两种结构的结点（可以使用联合类型实现）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;表结点，用于表示列表&lt;/li&gt;
  &lt;li&gt;原子结点，用于表示原子。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于上述定义，只要列表非空则可以确定为表头和表尾。&lt;/p&gt;

&lt;p&gt;所以，一个表结点可以由三个域组成：&lt;strong&gt;标志域&lt;/strong&gt;、&lt;strong&gt;指示表头的指针域&lt;/strong&gt;和&lt;strong&gt;指示表尾的指针域&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;然而，一个原子结点只需要两个域组成：&lt;strong&gt;标志域&lt;/strong&gt;和&lt;strong&gt;值域&lt;/strong&gt;。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:200px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/GList/List_Node.png&quot; /&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 广义表的头尾链表存储表示&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ATOM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LIST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ElemTag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// ATOM 原子	LIST 子表&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ElemTag&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;					&lt;span class=&quot;c1&quot;&gt;// 标志域&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;AtomType&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// 值域&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// 表头指针域 表尾指针域&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;基于头尾链表存储表示的具体广义表示意图：&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:200px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/GList/List_2.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;可以总结如下规律：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;空表的表头指针指向空。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;非空列表的表头指针&lt;/strong&gt;指向具体的&lt;strong&gt;表结点&lt;/strong&gt;。（而不是说表头指针自身就是表结点）&lt;/li&gt;
  &lt;li&gt;可以直接的看出原子和子表所在的层次。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;最高层表结点的个数就是列表的长度&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;扩展线性链表存储表示&quot;&gt;扩展线性链表存储表示&lt;/h3&gt;

&lt;p&gt;这种表示方式和传统的线性表（链表）很相似，至少每种结点都存在一个Next指针，表结点还存在表头指针。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/GList/List_3.png&quot; /&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 广义表的扩展线性链表存储表示&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ATOM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LIST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ElemTag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// ATOM 原子	LIST 子表&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ElemTag&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;					&lt;span class=&quot;c1&quot;&gt;// 标志域&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;AtomType&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// 值域&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// 表结点的表头指针&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;				&lt;span class=&quot;c1&quot;&gt;// 相当于线性链表的next,指向下一个元素结点&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;基于扩展线性链表存储表示的具体广义表示意图：&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/GList/List_4.png&quot; /&gt;&lt;/div&gt;

&lt;h2 id=&quot;m元多项式的表示&quot;&gt;$m$元多项式的表示&lt;/h2&gt;

&lt;p&gt;对于m元多项式，可以通过&lt;strong&gt;抽离公共元&lt;/strong&gt;的形式将大式化成&lt;strong&gt;以少一个元的小式为系数&lt;/strong&gt;的一元多项式。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;p&gt;$P(x, y, z)=x^{10} y^{3} z^{2}+2 x^{6} y^{3} z^{2}+3 x^{5} y^{2} z^{2}+x^{4} y^{4} z+6 x^{3} y^{4} z+2 y z+15$&lt;/p&gt;

&lt;p&gt;可以改写成：&lt;/p&gt;

&lt;p&gt;$p(x, y, z)=\left(\left(x^{10}+2 x^{6}\right) y^{3}+3 x^{5} y^{2}\right) z^{2}+\left(\left(x^{4}+6 x^{3}\right) y^{4}+2 y\right) z+15$&lt;/p&gt;

&lt;p&gt;再把化简后的式子用广义表表示，&lt;del&gt;（其实这个书上的(A,2)这样的表示不正确，2应该是A的元信息，而不是和A同级）&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;$P=z((A, 2),(B, 1),(15,0))$&lt;/p&gt;

&lt;p&gt;右边的列表中的每个元素分别为，关于$z$的一元多项式的每个系数和指数构成的列表。同理的，可以递推出$A,B$。&lt;/p&gt;

&lt;p&gt;$A=y((C, 3),(D, 2))$
	$C=x((1,10),(2,6))$
	$D=x((3,5))$
$B=y((E, 4),(F, 1))$
	$E=x((1,4)),(6,3) )$
	$F=x((2,0))$&lt;/p&gt;

&lt;p&gt;若以广义表的扩展线性链表存储表示其存储结构，则结点结构为：&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/GList/List_5.png&quot; /&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MPNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ElemTag&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// 区分结点类型&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;// 指数域&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 		&lt;span class=&quot;c1&quot;&gt;// 系数域&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MPNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// 表结点的表头指针&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MPNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// next指针&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MPList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/GList/List_6.png&quot; /&gt;&lt;/div&gt;

&lt;h2 id=&quot;广义表的递归算法&quot;&gt;广义表的递归算法&lt;/h2&gt;

&lt;h3 id=&quot;求广义表的深度&quot;&gt;求广义表的深度&lt;/h3&gt;

&lt;p&gt;广义表的深度定义为广义表中&lt;strong&gt;括弧的重数&lt;/strong&gt;，例如多元多项式广义表的深度就是该多项式中的变元个数。&lt;/p&gt;

&lt;h4 id=&quot;分析&quot;&gt;分析&lt;/h4&gt;

&lt;p&gt;设非空广义表为&lt;/p&gt;

&lt;p&gt;$LS = (a_1,a_2,…,a_n)$&lt;/p&gt;

&lt;p&gt;其中$a_i(i=1,2,…,n)$或为原子或为子表，那么求LS的深度可以分解为n个问题。每个子问题为求$a_i$的深度，若$a_i$是原子，则深度为0。若$a_i$为广义表，则按照上述处理，而$LS$为上述n个深度的最大值加1。定义空表的深度为1。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/GList/List_7.png&quot; /&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GListDepth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 采用头尾链表存储结构&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 					&lt;span class=&quot;c1&quot;&gt;// 空表深度为1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ATOM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 		&lt;span class=&quot;c1&quot;&gt;// 原子深度为0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dep&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GListDepth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// pp-&amp;gt;ptr.hp指向子表 或 原子&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dep&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;广义表的复制&quot;&gt;广义表的复制&lt;/h3&gt;

&lt;p&gt;任何一个非空广义表都可以分解成表头和表尾，一对确定的表头和表尾也可以唯一确定一个广义表。所以，复制一个广义表只需要分别复制表头和表尾，然后合成即可。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CopyGList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 采用头尾链表存储结构，由广义表L复制得到广义表T。&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 不是空表，就需要建立表结点&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OVERFLOW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ATOM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 如果是原子直接复制&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 复制表头&lt;/span&gt;
        	&lt;span class=&quot;n&quot;&gt;CopyGList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 复制表尾&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;CopyGList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;基于字符串创建广义表&quot;&gt;基于字符串创建广义表&lt;/h3&gt;

&lt;p&gt;下方将讨论如何将形如广义表形式的字符串解释成一个广义表。对于任意一个广义表字符串都可能有两种情况：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S = &apos;()&apos;&lt;/code&gt;，这是一个空的广义表。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S = &apos;(a1,a2,...,an)&apos;&lt;/code&gt;，$a_i$是S的子串，即S有n个子表。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;若采用&lt;strong&gt;头尾链表存储结构&lt;/strong&gt;的方式存储生成的广义表，那么这个广义表有$n$个表结点序列。且第$i$个表结点的表尾指针指向第$i+1$个表结点。第$n$个表结点的表尾指针为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;。如果把原子也看做子表的话，第$i$个表结点的表头指针&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hp&lt;/code&gt;指向由$a_i$建立的子表。&lt;/p&gt;

&lt;p&gt;由此，由S建广义表的问题可以转化成由$a_i$建子表的问题。$a_i$又有三种情况:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;带括弧的空白串&lt;/li&gt;
  &lt;li&gt;长度为1的单字符串&lt;/li&gt;
  &lt;li&gt;长度$&amp;gt;1$的字符串&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;显然&lt;strong&gt;前两种情况为递归的终结状态&lt;/strong&gt;，后一种情况为递归调用。&lt;/p&gt;

&lt;p&gt;假定函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;server(str,hstr)&lt;/code&gt;的功能为，从字符串&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt;中取出第一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;,&quot;&lt;/code&gt;之前的子串复制给&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hstr&lt;/code&gt;，并使&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt;成为删除子串&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hstr&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;,&apos;&lt;/code&gt;之后的剩余串。若&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt;中没有字符&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;,&lt;/code&gt;则操作后的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hstr&lt;/code&gt;即为当前的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt;，而操作后的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt;为空串&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CreateGList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SString&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 采用头尾链表存储结构，由广义表的书写形式串S创建广义表L。设emp= &quot;()&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StrCompare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 创建空表&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 字符串非空，所以表中存在结点，所以初始化一个结点&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OVERFLOW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StrLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 如果就是单独的一个原子，一个字符&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ATOM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         	&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LIST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;SubString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StrLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 脱外层括号&lt;/span&gt;
            
            &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 重复建造n个子表&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hsub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;CreateGList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hsub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StrEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// 表尾不空&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OVERFLOW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LIST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-05-16T00:00:00+08:00&quot;&gt;
                2019-05-16
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Thu, 16 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/16/GList/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/16/GList/</guid>
        
        
        <category>数据结构</category>
        
      </item>
    
      <item>
        <title>算法（二）：稀疏矩阵快速转置算法</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#稀疏矩阵&quot; id=&quot;markdown-toc-稀疏矩阵&quot;&gt;稀疏矩阵&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#数据结构&quot; id=&quot;markdown-toc-数据结构&quot;&gt;数据结构&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#转置&quot; id=&quot;markdown-toc-转置&quot;&gt;转置&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#普通算法&quot; id=&quot;markdown-toc-普通算法&quot;&gt;普通算法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#快速转置算法&quot; id=&quot;markdown-toc-快速转置算法&quot;&gt;快速转置算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文将阐述我是如何理解严蔚敏老师«数据结构»中的稀疏矩阵及其相关的三元组定义方式，以及与之相关的快速转置算法。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;稀疏矩阵&quot;&gt;稀疏矩阵&lt;/h2&gt;

&lt;p&gt;假设在\(m \times n\)的矩阵中，有\(t\)个&lt;strong&gt;不为零&lt;/strong&gt;的元素。令\(\delta=\frac{t}{m \times n}\)，称\(\delta\)为&lt;strong&gt;稀疏因子&lt;/strong&gt;。通常认为\(\delta\le0.05\)时，该矩阵则可以被称作&lt;strong&gt;稀疏矩阵&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;数据结构&quot;&gt;数据结构&lt;/h3&gt;

&lt;p&gt;通常使用&lt;strong&gt;三元组顺序表&lt;/strong&gt;的形式来压缩表示一个稀疏矩阵，每个三元组包括的信息有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt; 非零元素的行下标&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;j&lt;/code&gt; 非零元素的列下标&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt; 元素值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三元组顺序表又将和一些&lt;strong&gt;元信息&lt;/strong&gt;一起保存在一个联合结构（书中写的是union但我认为应该使用 struct，否则mu,nu,tu的数据会被覆盖）中以表示一个稀疏矩阵，这些基础信息包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mu&lt;/code&gt; 矩阵的行数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nu&lt;/code&gt; 矩阵的列数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tu&lt;/code&gt; 矩阵非零元素的总个数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;若使用&lt;del&gt;伪&lt;/del&gt;C语言，可以有具体的如下定义。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;# define MAXSIZE 12500 			// 最大的非零元素个数
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;					&lt;span class=&quot;c1&quot;&gt;// 分别表示非零元素的行下标和列下标&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ElemType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;					&lt;span class=&quot;c1&quot;&gt;// 元素值&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Triple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Triple&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAXSIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; 	&lt;span class=&quot;c1&quot;&gt;// 所有的非零元素， data[0]弃用&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;				&lt;span class=&quot;c1&quot;&gt;// 矩阵的行数、列数和总共的非零元素个数&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TSMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;其实还有一个隐性的要求（虽然书中并没有明确说明）：&lt;/strong&gt;data中的数据以&lt;strong&gt;行&lt;/strong&gt;为&lt;strong&gt;主序&lt;/strong&gt;存储（从第一行起依次存储）。&lt;/p&gt;

&lt;h3 id=&quot;转置&quot;&gt;转置&lt;/h3&gt;

&lt;p&gt;根据上述的数据结构，若要将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TSMatrix before&lt;/code&gt;转置成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TSMatrix after&lt;/code&gt;，则务必需要经历如下三个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TSMatrix&lt;/code&gt;中的元信息&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mu&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nu&lt;/code&gt;互换。&lt;/li&gt;
  &lt;li&gt;将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt;中每个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Triple&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;j&lt;/code&gt;互换。&lt;/li&gt;
  &lt;li&gt;重新整理&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt;使其满足&lt;strong&gt;行主序&lt;/strong&gt;。&lt;strong&gt;（难以实现）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:400px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/TSMatrix/TS_Trans.png&quot; /&gt;&lt;/div&gt;

&lt;h2 id=&quot;普通算法&quot;&gt;普通算法&lt;/h2&gt;

&lt;p&gt;最直观的想法是：因为&lt;strong&gt;转置后行列互换&lt;/strong&gt;，转置后需要确保行主序，因此直接从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;before&lt;/code&gt;的第一列开始以&lt;strong&gt;列遍历&lt;/strong&gt;处理。&lt;/p&gt;

&lt;p&gt;对于具体的某一列，&lt;strong&gt;遍历所有的非零元素&lt;/strong&gt;，判断每个元素的列值是否等于当前列。又因为，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt;是按照&lt;strong&gt;行值排列&lt;/strong&gt;的，可以确保在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;after.data&lt;/code&gt;中的每&lt;strong&gt;行&lt;/strong&gt;元素也一定可以按照&lt;strong&gt;列值&lt;/strong&gt;从小到大排列。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:400px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/TSMatrix/TSMatrix_trans_normal.gif&quot; /&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TransposeSMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TSMatrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TSMatrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// after.data的写入指针&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 遍历列&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
               	&lt;span class=&quot;c1&quot;&gt;// 遍历before.data&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// 元素的列正好是当前被遍历的列&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
                    &lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    
                    &lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该算法的时间复杂度为\(O(nu \times tu)\)，又因为\(tu\)和\(mu \times nu\)同数量级，因此实际复杂度为\(O(nu^2 \times mu)\)，相比于&lt;strong&gt;非压缩情况&lt;/strong&gt;的转置算法的时间复杂度\(O(nu \times mu)\)要耗时很多，除非\(tu &amp;lt;&amp;lt; mu \times nu\)。所以我们需要探究一个时间复杂度更低的转置算法，用空间换取时间。&lt;/p&gt;

&lt;h2 id=&quot;快速转置算法&quot;&gt;快速转置算法&lt;/h2&gt;

&lt;p&gt;和&lt;a href=&quot;/2019/05/09/KMP/&quot;&gt;KMP&lt;/a&gt;相似的，我们可以通过&lt;strong&gt;预处理&lt;/strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;before&lt;/code&gt;获取一些提炼出一些额外的信息，从而&lt;strong&gt;避免嵌套的循环&lt;/strong&gt;。目标如下：只遍历一次&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;before.data&lt;/code&gt;，将每个元素行列互换后填入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;after.data&lt;/code&gt;的&lt;strong&gt;合适&lt;/strong&gt;的位置。&lt;/p&gt;

&lt;p&gt;那么需要预处理出哪些信息才能在遍历时直接得出合适的位置呢？可以做如下的思考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;转置的实质是行列互换。
    &lt;ul&gt;
      &lt;li&gt;因此如果知道&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;before.data&lt;/code&gt;中&lt;strong&gt;某列的第1个非0元素&lt;/strong&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;after.data&lt;/code&gt;中的位置\(pos\)（某行的第1个非0元素），那么这一列的&lt;strong&gt;下一个非0元素&lt;/strong&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;after.data&lt;/code&gt;中的位置一定为\(pos+1\)，因为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt;是行主序的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;又&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;before.data&lt;/code&gt;是行主序的
    &lt;ul&gt;
      &lt;li&gt;又因为，遍历&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;before.data&lt;/code&gt;时是可以必然确保对于&lt;strong&gt;特定的列&lt;/strong&gt;，遍历的次序&lt;strong&gt;一定是按照行号从低到高&lt;/strong&gt;进行的。
        &lt;ul&gt;
          &lt;li&gt;例如：本例中（列数为1）的第3个元素行号是3，第7个元素行号是6，行号随着遍历是从低到高的。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;因此如果知道&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;before.data&lt;/code&gt;中&lt;strong&gt;每列的第1个非0元素&lt;/strong&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;after.data&lt;/code&gt;中的位置，只需要遍历一遍&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;before.data&lt;/code&gt;就可以把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;after.data&lt;/code&gt;计算出来。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如何计算&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;before.data&lt;/code&gt;中&lt;strong&gt;每列的第1个非0元素&lt;/strong&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;after.data&lt;/code&gt;中的位置?
    &lt;ul&gt;
      &lt;li&gt;递推：&lt;strong&gt;上一列的第1个非0元素&lt;/strong&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;after.data&lt;/code&gt;中的位置 + &lt;strong&gt;上一列非0元素的总个数&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如何求&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;before.data&lt;/code&gt;中&lt;strong&gt;每列非0元素&lt;/strong&gt;的总个数？
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;遍历before.data(tu)就行&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以总的算法过程就应该是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;遍历&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;before.data&lt;/code&gt;，求出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;before.data&lt;/code&gt;中&lt;strong&gt;每列非0元素&lt;/strong&gt;的总个数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;num[]&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
  &lt;li&gt;初始化&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;before.data&lt;/code&gt;中第1列的第1个非0元素在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;after.data&lt;/code&gt;中的位置为1。&lt;/li&gt;
  &lt;li&gt;遍历&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;before.data&lt;/code&gt;中所有的列，配合&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;num[]&lt;/code&gt;递推出，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;before.data&lt;/code&gt;中&lt;strong&gt;每列的第1个非0元素&lt;/strong&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;after.data&lt;/code&gt;中的位置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cpot[]&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;遍历&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;before.data(tu)&lt;/code&gt;，遇到的每一个元素都&lt;strong&gt;视作它所在列的第一个元素&lt;/strong&gt;，根据&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cpot[col]&lt;/code&gt;填入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;after.data&lt;/code&gt;中，再把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cpot[col]&lt;/code&gt;自增1。&lt;/li&gt;
&lt;/ol&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:400px;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/TSMatrix/TSMatrix_fasttrans.gif&quot; /&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Status&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;FastTransposeSMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TSMatrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TSMatrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        	&lt;span class=&quot;c1&quot;&gt;// 通过每一个before.data中的元素计数，得出每列非0元素数量&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 递推计算before.data中每列的第1个非0元素在after.data中的位置,初始化&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cpot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cpot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 填入after.data&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 每个被遍历到的非0元素都被视作，它所在列的第1个非0元素&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;col&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            
            &lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            
            &lt;span class=&quot;c1&quot;&gt;// 当该列下一个元素被遍历到时，正好需要后移一位&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;          
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;综上可以分析出其时间复杂度为\(O(nu + tu)\) 即 \(O(nu + nu \times mu)\) 即 \(O(nu \times mu)\)。&lt;/p&gt;
 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-05-15T00:00:00+08:00&quot;&gt;
                2019-05-15
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Wed, 15 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/15/QuickMatrixTrans/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/15/QuickMatrixTrans/</guid>
        
        <category>数据结构</category>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>自建图床</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#背景&quot; id=&quot;markdown-toc-背景&quot;&gt;背景&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#环境&quot; id=&quot;markdown-toc-环境&quot;&gt;环境&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#相关服务分析&quot; id=&quot;markdown-toc-相关服务分析&quot;&gt;相关服务分析&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#社交软件&quot; id=&quot;markdown-toc-社交软件&quot;&gt;社交软件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#图床服务&quot; id=&quot;markdown-toc-图床服务&quot;&gt;图床服务&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#对象存储&quot; id=&quot;markdown-toc-对象存储&quot;&gt;对象存储&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#自建图床&quot; id=&quot;markdown-toc-自建图床&quot;&gt;自建图床&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#goodsync&quot; id=&quot;markdown-toc-goodsync&quot;&gt;GoodSync&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#如何自建图床&quot; id=&quot;markdown-toc-如何自建图床&quot;&gt;如何自建图床&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;随着文章的数目变多，博客的加载速度变得越来越慢尤其是主页需要显示每篇文章开头被截取到的图片的时候。所以，是时候考虑一下图床的问题了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;在此之前，我其实一直都是在&lt;del&gt;“蹭”&lt;/del&gt;Github的存储功能——自建了一个专门用于存放静态资源的仓库，每次都通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Download&lt;/code&gt;按钮获取外链。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:600px;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/IntroPicBed/Github_picbed.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;一开始的时候效果不错，毕竟不需要付费。但是还是有很多直接暴露出来的问题，比如是否违反用户协定（&lt;del&gt;虽然管理员好像有声明过这并不属于abuse，并且官方也提供Download按钮&lt;/del&gt;），速度慢，&lt;a href=&quot;https://rawgit.com/&quot;&gt;RawGit&lt;/a&gt;今年十月将停止服务。&lt;/p&gt;

&lt;p&gt;不过这些都不是真正的问题，真正的问题是：如果基于&lt;strong&gt;Repo&lt;/strong&gt;的存储必须持有整个仓库才能进行数据的维护而如果基于&lt;strong&gt;Issue&lt;/strong&gt;的存储则难以实现不同静态文件对应不同文件夹的管理，并且可能会涉及abuse问题。&lt;/p&gt;

&lt;h2 id=&quot;环境&quot;&gt;环境&lt;/h2&gt;

&lt;p&gt;在选择并实施新的解决方案之前，首先需要分析一下我自己的（博客）生产环境以及对图床服务的相关需求。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;主要在PC上处理图片素材，PC大概一个月关机一次。&lt;/li&gt;
  &lt;li&gt;在PC上书写博客较多，在MBP上一般书写的是即兴突然来灵感之类的内容。两者有上传图片的需求，MBP上的图片主要是引用外部资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于图床服务（其实我更愿意描述成&lt;strong&gt;静态文件存储服务&lt;/strong&gt;），我的需求或许会严格一些。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务可以挂，&lt;strong&gt;数据不能丢&lt;/strong&gt;，丢了写的所有的文章都报废。&lt;/li&gt;
  &lt;li&gt;服务重置后，文章中的&lt;strong&gt;引用链接&lt;/strong&gt;尽可能的不要变化。（静态资源外链的值需要是&lt;strong&gt;可以被预期的&lt;/strong&gt;，甚至可以被设置的。这样最大的好处就在于，当服务重置时上传新的文件数据不需要建立新的映射关系。）&lt;/li&gt;
  &lt;li&gt;服务尽可能的不要关联到其他操作如域名备案。&lt;/li&gt;
  &lt;li&gt;服务不容易挂。&lt;/li&gt;
  &lt;li&gt;价格越低越好。&lt;/li&gt;
  &lt;li&gt;速度越快越好。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;相关服务分析&quot;&gt;相关服务分析&lt;/h2&gt;

&lt;p&gt;大体上要实现静态文件存储并提供外链主要有那么几种选择：“蹭“一些大体量的社交软件及相关相册程序、纯粹的图床服务、对象存储（云）服务、基于（实体、云、虚拟）主机自建图床。&lt;/p&gt;

&lt;h4 id=&quot;社交软件&quot;&gt;社交软件&lt;/h4&gt;

&lt;p&gt;如微博（针对外链启用了相关屏蔽），&lt;a href=&quot;https://imgur.com/&quot;&gt;imgur&lt;/a&gt;等。&lt;/p&gt;

&lt;p&gt;最大好处就是&lt;strong&gt;快，它比你更想让数据更快地输出到用户的浏览器中&lt;/strong&gt;且&lt;strong&gt;免费&lt;/strong&gt;和&lt;strong&gt;良好的抗攻击性&lt;/strong&gt;，毕竟它是实际的为用户提供服务的应用程序。当然坏处也很明显：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务本身的不稳定性（不影响数据）
    &lt;ul&gt;
      &lt;li&gt;例如发布在微博的静态资源已经开启了防外链功能，你需要付出一定的成本（设置Http Header等），才能让它在如期显示在你的站点上。&lt;/li&gt;
      &lt;li&gt;随时它都可能更换资源的URL。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数据本身的不安全性。
    &lt;ul&gt;
      &lt;li&gt;本身就没有购买相关服务许可，这意味着你的行为（大量no-sense的数据）可能构成abuse，除非它在协议中有相关的允诺（不过我想不到他有什么理由无偿地允诺），那么你的数据随时可能被删除。&lt;/li&gt;
      &lt;li&gt;你的数据将被公开给公众，经过程序合适的推荐算法，任何人都能通过Web甚至在主页看到它。你的无意义的数据或许会触犯某些相关条例，又或许被用户举报最后依旧有被删除的风险。&lt;/li&gt;
      &lt;li&gt;前两者讨论的仅仅是社交程序本身基于其个体利益对你数据的审查。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;和绝大多数图床服务的弊病一样，文件管理功能几乎没有。你无法快速的通过你的博客名定位到一系列相关资源的所在；同时一旦服务停止、社交软件中的数据被清除或篡改，通过备份文件重新上传后的链接又将是全新的，这意味着你得逐一匹配文章中引用过的图片并修改他们的URL。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;图床服务&quot;&gt;图床服务&lt;/h4&gt;

&lt;p&gt;如&lt;a href=&quot;https://sm.ms/&quot;&gt;sm.ms&lt;/a&gt;，相比于社交软件则更加&lt;strong&gt;直接&lt;/strong&gt;；也有更&lt;strong&gt;人性化的用户界面&lt;/strong&gt;；同时服务本身的&lt;strong&gt;稳定性&lt;/strong&gt;相较于社交软件会大很多，不存在”盗链”这一概念。缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;部分（免费）图床服务只可上传文件不可管理（删除），甚至直接地查看自己一共上传了那些图片。&lt;/li&gt;
  &lt;li&gt;图床服务一般只有小的公司或者个体组织维护，可靠性存在问题，可能随时因为审查或是自身原因停止服务。&lt;/li&gt;
  &lt;li&gt;上文所述的无法快速定位，需要自建映射。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我认为图床服务本身相比于盗链是更靠谱的选择，它适用于一些&lt;strong&gt;临时&lt;/strong&gt;的，&lt;strong&gt;不重要&lt;/strong&gt;的行为例如在论坛里展示大量的图片。&lt;/p&gt;

&lt;h4 id=&quot;对象存储&quot;&gt;对象存储&lt;/h4&gt;

&lt;p&gt;对象存储相比于前面两者就&lt;strong&gt;靠谱&lt;/strong&gt;且&lt;strong&gt;专业&lt;/strong&gt;很多很多了，毕竟是付费服务并且云服务也只有体量巨大的那么几个公司才玩的好（他们能把成本压低垄断市场）。下面主要说说我体验过的两家对象存储，七牛云和腾讯云。&lt;/p&gt;

&lt;p&gt;我不喜欢七牛云，虽然他好像在知乎用户中的口碑很不错。因为他强行地把&lt;strong&gt;存储服务和CDN绑定到一起&lt;/strong&gt;，虽然说提供10G的存储和10G的流量，但是一旦他提供的绑定到CDN的测试域名失效，你的所有数据都像是被扣留在里面了一样。&lt;/p&gt;

&lt;p&gt;你能做的，只有乖乖地&lt;strong&gt;租用域名&lt;/strong&gt;、&lt;strong&gt;备案&lt;/strong&gt;、&lt;strong&gt;绑定CDN&lt;/strong&gt;，开始承担CDN费用。同时如果你使用的是基于Github Pages构建的博客，你还需要负担&lt;strong&gt;HTTPS&lt;/strong&gt;的费用。至于整体的七牛云后台的体验，我也觉得比较用户界面比较劣质（相比于阿里云和腾讯云）；再加上我提交工单询问过CDN的问题，得到的回复却是遮遮掩掩、避重就轻，我就决定不再考虑这家提供的服务了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;对象存储一定要配合CDN使用吗？30天后测试域名过期，我没有域名是不是就无法通过浏览器获取对象存储中的内容？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;解决方法：&lt;/p&gt;

  &lt;p&gt;回收测试域名对您的存储资源没有影响，不会删除您的资源，也不需要重新上传资源。&lt;/p&gt;

  &lt;p&gt;您绑定自定义域名后，通过自定义域名访问即可。&lt;/p&gt;

  &lt;p&gt;如果您的域名已经在工信部备案，请参考域名绑定教程：https://developer.qiniu.com/kodo/kb/5158/how-to-transition-from-test-domain-name-to-a-custom-domain-name&lt;/p&gt;

  &lt;p&gt;如果您需要了解测试域名的使用规范请参考：https://developer.qiniu.com/fusion/kb/1319/test-domain-access-restriction-rules&lt;/p&gt;

  &lt;p&gt;-————————————-&lt;/p&gt;

  &lt;p&gt;Q:部分资源可以访问，新资源无法访问。&lt;/p&gt;

  &lt;p&gt;A:旧资源可以访问是因为cdn缓存未失效，您刷新cdn缓存后现象会保持一致。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;七牛云还有一个不好的地方，就是他的&lt;strong&gt;存储内容管理比较劣质&lt;/strong&gt;，他是使用&lt;strong&gt;手动添加前缀字符串的方式&lt;/strong&gt;实现而不是直接的使用文件夹管理的方式来实现资源的管理的。这意味着，所有的资源都将冗杂地平铺在一个Bucket里面，而不是有目录的树级显示。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/IntroPicBed/qiniuyun_content_manage.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;相比之下腾讯云就显得可靠很多了（虽然他的用户界面依旧不及阿里云），虽然没有永久的免费政策（提供了6个月免费政策）。但是总体上就直截了当很多，哪里有需要付费的地方都说的很明白绝不藏着掖着。&lt;/p&gt;

&lt;p&gt;同时，相比于七牛云他在两个方面都是完胜的。首先它并&lt;strong&gt;不需要CDN就能提供下载外链&lt;/strong&gt;（基于腾讯云本身的域名），再者&lt;strong&gt;他支持传统云存储服务一般的文件夹管理模式&lt;/strong&gt;，这意味着一旦弃用腾讯云或者腾讯云服务失效后博客本身可以基本上不需要变动。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/IntroPicBed/tengxunyun_content_manage.png&quot; /&gt;&lt;/div&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/IntroPicBed/tengxunyun_wailian.png&quot; /&gt;&lt;/div&gt;

&lt;h4 id=&quot;自建图床&quot;&gt;自建图床&lt;/h4&gt;

&lt;p&gt;所以如果自建图床不能提供更优秀的特性，我应该会选择腾讯云的对象存储服务。于是，我开始了我的自建图床之旅。&lt;/p&gt;

&lt;p&gt;我要考虑的问题无非那么几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;是否需要使用CDN？&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;怎么样操作能比云存储更方便？&lt;/li&gt;
  &lt;li&gt;或许自实现抗攻击是极难的，那被攻击后如何快速恢复服务？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个时候我首先想到的是科学上网的VPS，它的下行带宽足够的大（至少够我个人使用），我不再需要支付额外的费用。当初要不是我觉得Github Pages可以稳定免费的提供静态网站的托管并且抗攻击的问题不再需要我考虑，或许我会把博客直接部署在它上面。&lt;/p&gt;

&lt;p&gt;那下面两个需求如何实现呢？ 就需要引入下一个我想说的话题，Goodsync。&lt;/p&gt;

&lt;h2 id=&quot;goodsync&quot;&gt;GoodSync&lt;/h2&gt;

&lt;p&gt;关于备份，有两个极优秀的软件我不得不提——Macrium Reflect 和 GoodSync。如果说Macrium为我提供了整套的系统以及磁盘备份的解决方案，那么GoodSync可以说是&lt;strong&gt;只要有正在运行的系统（他也可以运行在U盘里）存在，它可以解决任何的备份、同步、传输需求&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;它支持&lt;strong&gt;任意&lt;/strong&gt;（可以非本机，可以在内网，可以是云存储）文件夹到任意文件夹&lt;strong&gt;备份&lt;/strong&gt;与&lt;strong&gt;同步&lt;/strong&gt;。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:600px;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/IntroPicBed/Goodsync_from_to.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;同时它还支持自动执行同步、备份功能，通过检测文件夹的变动，所以它可以满足我上述的两个需求。&lt;/p&gt;

&lt;h2 id=&quot;如何自建图床&quot;&gt;如何自建图床&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;VPS开启Http Server（Apache、Nginx等），并确保它能通过你预期的URL返回资源目录中的文件。&lt;/li&gt;
  &lt;li&gt;对于非主要上传资源的设备，直接通过&lt;a href=&quot;https://filezilla-project.org/&quot;&gt;FileZilla&lt;/a&gt;等FTP程序上传资源。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在主要可能会上传资源的设备（我的是MBP和PC）建立一个&lt;strong&gt;静态资源文件夹&lt;/strong&gt;和一个&lt;strong&gt;备份文件夹&lt;/strong&gt;。每次需要将资源上传到图床时，只需要将资源拖入静态资源文件夹的相关目录中（如图，Blog为每片博文持有的资源的总目录，Set则是一个共享用的静态资源的无序集目录）。&lt;strong&gt;每次上传资源只需要将图片拖入即可。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;在GoodSync中建立同步任务将本地的&lt;strong&gt;静态资源文件夹&lt;/strong&gt;与VPS的&lt;strong&gt;静态资源文件夹&lt;/strong&gt;同步，同时建立备份任务将本地的&lt;strong&gt;静态资源文件夹&lt;/strong&gt;增量备份（取消&lt;strong&gt;触发删除&lt;/strong&gt;）到&lt;strong&gt;备份文件夹&lt;/strong&gt;，两个任务都设置定期执行。&lt;/li&gt;
  &lt;li&gt;当VPS被攻击或出现异常时，只需将本地的备份文件夹内的数据覆盖回静态资源文件夹，并确保域名一致即可。&lt;/li&gt;
  &lt;li&gt;修改_config.yml给静态资源域名设置一个宏。&lt;/li&gt;
&lt;/ol&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/IntroPicBed/StaticData_dir.png&quot; /&gt;&lt;/div&gt;

 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-05-13T00:00:00+08:00&quot;&gt;
                2019-05-13
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Mon, 13 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/13/Pic_bed/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/13/Pic_bed/</guid>
        
        <category>GoodSync</category>
        
        <category>SSH</category>
        
        
        <category>生产环境</category>
        
      </item>
    
      <item>
        <title>算法（一）：KMP</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#bf&quot; id=&quot;markdown-toc-bf&quot;&gt;BF&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#kmp&quot; id=&quot;markdown-toc-kmp&quot;&gt;KMP&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#next数组&quot; id=&quot;markdown-toc-next数组&quot;&gt;Next数组&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#逐步讨论&quot; id=&quot;markdown-toc-逐步讨论&quot;&gt;逐步讨论&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#ababdababab&quot; id=&quot;markdown-toc-ababdababab&quot;&gt;ababdababab&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#实现&quot; id=&quot;markdown-toc-实现&quot;&gt;实现&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#kmp-1&quot; id=&quot;markdown-toc-kmp-1&quot;&gt;KMP&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#next&quot; id=&quot;markdown-toc-next&quot;&gt;Next&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#nextval&quot; id=&quot;markdown-toc-nextval&quot;&gt;Nextval&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#后记&quot; id=&quot;markdown-toc-后记&quot;&gt;后记&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;KMP算法应该算是我学习程序开发以来第一个真正独立学习理解的算法，看了许多网络上的视频和文字教程依旧很难彻底掌握（尤其是next数组的计算过程），所以我将我对于该算法的主观认识记录于此。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;bf&quot;&gt;BF&lt;/h2&gt;

&lt;p&gt;Brute-Force(BF) 算法又称naive算法，是对字符串子串搜索最简单明了的算法。其主旨就是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不处理模式串&lt;/li&gt;
  &lt;li&gt;模式串从目标串&lt;strong&gt;第一个元素&lt;/strong&gt;起逐一匹配&lt;/li&gt;
  &lt;li&gt;发现无法匹配，模式串匹配右移一位，从下一位目标串元素重新初始逐一元素匹配&lt;/li&gt;
&lt;/ol&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/bf_quickest.gif&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;p&gt;虽然简单易懂，但是同时也导致了复杂度较高，最慢的情形其复杂度可以到达O（模式串长 * 目标串长）。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/bf_lowest.gif&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;h2 id=&quot;kmp&quot;&gt;KMP&lt;/h2&gt;

&lt;p&gt;但是如果仔细观察，可以发现&lt;strong&gt;模式串&lt;/strong&gt;本身是可以自带一些&lt;strong&gt;可被预先计算出&lt;/strong&gt;的&lt;strong&gt;可用于加速匹配的信息&lt;/strong&gt;的。&lt;/p&gt;

&lt;p&gt;当模式串的第K位失配时，前K-1位必然是匹配的，如果直接整体后移一位重新从头开始匹配那之前的那些&lt;strong&gt;已经匹配的信息&lt;/strong&gt;就被浪费了。于是我们可以寻找&lt;strong&gt;最大的必定不需要再匹配的串&lt;/strong&gt;，那这个串是什么呢？&lt;/p&gt;

&lt;p&gt;很显然，这个串就是[1,K-1]位串中&lt;strong&gt;最大且相同&lt;/strong&gt;的&lt;strong&gt;头尾&lt;/strong&gt;串（S）。当失配发生，可以直接&lt;strong&gt;保持目标串中的失配元素不变&lt;/strong&gt;，移动模式串，K-1-S串长个单位重新匹配，这就是KMP算法。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/KMP.gif&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;p&gt;为什么要移动K-1-S串长个单位？失配元素前方一共有K-1个元素，最大相同头尾串长为S。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/KMP_shipei.PNG&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;p&gt;若移动小于K-1-S长度(例如K-1-S-1 = K - 1 - (S+1))，则必然无法匹配，因为不存在&lt;strong&gt;更大&lt;/strong&gt;的相同首尾串，如下图中（bab不是相同首尾串，故必然不匹配）。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/KMP_shipei_1.PNG&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;p&gt;若移动大于K-1-S长度(例如K-1-S+1 = K - 1 - (S-1))，有可能匹配（当S-1同样是相同子串时），但是可能会因为多移动了位数而遗漏结果。&lt;/p&gt;

&lt;p&gt;KMP算法本身比较好理解，而关于KMP的实现需要引入一个Next数组（由模式串预处理出的数组），Next数组的本身的算法则很难理解。&lt;/p&gt;

&lt;h2 id=&quot;next数组&quot;&gt;Next数组&lt;/h2&gt;

&lt;p&gt;Next数组的含义很直观，就是&lt;strong&gt;第几个元素失配时应该右移模式串重新匹配第几个元素&lt;/strong&gt;（不同的教材采用的首元素索引序号不同有的是0有的是1，这也是Next数组算法难以理解的一大原因，所以文中讨论索引序号都直接使用的是&lt;strong&gt;第&lt;/strong&gt;几个元素）。&lt;/p&gt;

&lt;p&gt;Next数组的算法步骤如下图所示，在我们逐步讨论完其算法过程后再会看这张动图或许你会有更深刻地理解。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/next.gif&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;h3 id=&quot;逐步讨论&quot;&gt;逐步讨论&lt;/h3&gt;

&lt;p&gt;对于模式串的首个元素的Next值，约定为&lt;strong&gt;首元素索引值 - 1&lt;/strong&gt;，这么做仅仅是为了&lt;strong&gt;方便实现递归算法&lt;/strong&gt;。这个值&lt;strong&gt;不一定只为首元素的Next值&lt;/strong&gt;，经过优化后可能为其他元素的Next值，这个值（首元素索引 - 1）的含义是：&lt;/p&gt;

&lt;p&gt;将&lt;strong&gt;模式串&lt;/strong&gt;的&lt;strong&gt;首元素&lt;/strong&gt;移动到&lt;strong&gt;失配元素后一位&lt;/strong&gt;并从首元素开始，重新匹配。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/Next_interpretation_0.gif&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;h4 id=&quot;ababdababab&quot;&gt;ababdababab&lt;/h4&gt;

&lt;p&gt;第一步：初始化首元素的Next值。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/next_step/0 04-49-07-736.png&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;p&gt;第二步：&lt;strong&gt;讨论第一个元素的Next值&lt;/strong&gt;，从而决定第二个元素的Next值。发现第二个元素无法匹配时，&lt;strong&gt;前方并不存在免匹配元素（不存在相同的首尾串）&lt;/strong&gt;，故值为首元素索引。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/next_step/0 04-49-07-7696.png&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;p&gt;第三步：&lt;strong&gt;讨论第二个元素的Next值&lt;/strong&gt;，从而决定第三个元素的Next值。发现第三个元素无法匹配时，第二个元素无法通过它自身的Next值对应的元素（索引为1的元素a）以及如此递归，构成相同首尾的串。因此第三个元素前方不存在相同首尾串，因此其Next值为首元素索引。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/next_step/0 04-49-07-7982.png&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;p&gt;第四步：&lt;strong&gt;讨论第三个元素的Next值&lt;/strong&gt;，从而决定第四个元素的Next值。发现第四个元素无法匹配时，第三个元素（a）与其Next值（1）对应的元素（a）（第一个元素）相同，因此&lt;strong&gt;第三个元素必定在一个具有相同首尾的串的尾串中，并且扮演最尾元素的角色&lt;/strong&gt;，其串长为0（首元素的Next值为0，在这里阻止递归，约定其串长为0）+1 = 1。因此第四个元素的Next值为&lt;strong&gt;上述的新构建的首串尾元素的索引值 （第三个元素的Next值） + 1&lt;/strong&gt;即2。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/next_step/0 04-49-07-8273.png&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;p&gt;第五步：&lt;strong&gt;讨论第四个元素的Next值&lt;/strong&gt;，从而决定第五个元素的Next值。（基本上与第四步相同）发现第五个元素无法匹配时，第四个元素（b）与其Next值（2）对应的元素（b）（第二个元素）相同，因此&lt;strong&gt;第四个元素必定在一个具有相同首尾的串的尾串中，并且扮演最尾元素的角色&lt;/strong&gt;，其串长为（（首元素的Next值为0，在这里阻止递归，约定其串长为0）+1 ） + 1= 2。因此第五个元素的Next值为&lt;strong&gt;上述的新构建的首串尾元素的索引值 （第四个元素的Next值） + 1&lt;/strong&gt;即3。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/next_step/0 04-49-07-8568.png&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;p&gt;第六步：&lt;strong&gt;讨论第五个元素的Next值&lt;/strong&gt;，从而决定第六个元素的Next值。发现第六个元素无法匹配时，第五个元素（d）与其Next值（3）对应的元素（a）（第三个元素）不相同，也不与第三个元素的Next值（1）对应的元素（a）相同，如此递归都无法找到一个相同的元素构成相同首尾的串。因此&lt;strong&gt;第一直到第五个元素构成的串不存在相同的首部和尾部&lt;/strong&gt;，因此&lt;strong&gt;不存在免匹配的部分&lt;/strong&gt;，因此第六个元素的Next值为首元素的索引值即为1。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/next_step/0 04-49-07-8829.png&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;p&gt;第七步：&lt;strong&gt;讨论第六个元素的Next值&lt;/strong&gt;，从而决定第七个元素的Next值。发现第七个元素无法匹配时，第六个元素（a）与其Next值（1）对应的元素（a）（第一个元素）相同，因此&lt;strong&gt;第六个元素必定在一个具有相同首尾的串的尾串中，并且扮演最尾元素的角色&lt;/strong&gt;，其串长为（首元素的Next值为0，在这里阻止递归，约定其串长为0）+1  = 1。因此第七个元素的Next值为&lt;strong&gt;上述的新构建的首串尾元素的索引值 （第六个元素的Next值） + 1&lt;/strong&gt;即2。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/next_step/0 04-49-07-9085.png&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;p&gt;第八步：&lt;strong&gt;讨论第七个元素的Next值&lt;/strong&gt;，从而决定第八个元素的Next值。发现第八个元素无法匹配时，第七个元素（b）与其Next值（2）对应的元素（b）（第二个元素）相同，因此&lt;strong&gt;第七个元素必定在一个具有相同首尾的串的尾串中，并且扮演最尾元素的角色&lt;/strong&gt;，其串长为（（首元素的Next值为0，在这里阻止递归，约定其串长为0）+1）+1  = 2。因此第八个元素的Next值为&lt;strong&gt;上述的新构建的首串尾元素的索引值 （第七个元素的Next值） + 1&lt;/strong&gt;即3。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/next_step/0 04-49-07-9335.png&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;p&gt;第九步：&lt;strong&gt;讨论第八个元素的Next值&lt;/strong&gt;，从而决定第九个元素的Next值。发现第九个元素无法匹配时，第八个元素（a）与其Next值（3）对应的元素（a）（第三个元素）相同，因此&lt;strong&gt;第八个元素必定在一个具有相同首尾的串的尾串中，并且扮演最尾元素的角色&lt;/strong&gt;，其串长为（（（首元素的Next值为0，在这里阻止递归，约定其串长为0）+1）+1）+ 1= 3。因此第九个元素的Next值为&lt;strong&gt;上述的新构建的首串尾元素的索引值 （第八个元素的Next值） + 1&lt;/strong&gt;即4。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/next_step/0 04-49-07-9591.png&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;p&gt;第十步：&lt;strong&gt;讨论第九个元素的Next值&lt;/strong&gt;，从而决定第十个元素的Next值。发现第十个元素无法匹配时，第九个元素（b）与其Next值（4）对应的元素（b）（第四个元素）相同，因此&lt;strong&gt;第九个元素必定在一个具有相同首尾的串的尾串中，并且扮演最尾元素的角色&lt;/strong&gt;，其串长为（（（（首元素的Next值为0，在这里阻止递归，约定其串长为0）+1）+1）+ 1）+ 1= 4。因此第十个元素的Next值为&lt;strong&gt;上述的新构建的首串尾元素的索引值 （第九个元素的Next值） + 1&lt;/strong&gt;即5。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/next_step/0 04-49-07-9847.png&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;p&gt;第十一步：&lt;strong&gt;讨论第十个元素的Next值&lt;/strong&gt;，从而决定第十一个元素的Next值。发现第十一个元素无法匹配时，第十个元素（a）与其Next值（5）对应的元素（d）（第五个元素）不相同。而和第五个元素d的Next值（3）对应的元素a相同，因此&lt;strong&gt;第十个元素必定在一个具有相同首尾的串的尾串中，并且扮演最尾元素的角色&lt;/strong&gt;，其串长为（（（首元素的Next值为0，在这里阻止递归，约定其串长为0）+1）+1）+ 1= 3。因此第十个元素的Next值为&lt;strong&gt;上述的新构建的首串尾元素的索引值 （第五个元素的Next值） + 1&lt;/strong&gt;即4。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/next_step/0 04-49-08-0092.png&quot; /&gt;&lt;/div&gt;&lt;/center&gt;

&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;

&lt;h3 id=&quot;kmp-1&quot;&gt;KMP&lt;/h3&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// T 模式串， S目标串， pos第几个字符之后搜索&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 约定索引起始值为1&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Index_KMP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SString&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SString&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// i 目标串指针，j 模式串指针&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 只要指针没有溢出对应的串&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 如果将要和 目标串元素 匹配的元素是模式串首元素前一位的元素&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 或者&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 当前目标串元素 和 模式串元素可以匹配&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// if (j == first_indexof(T) - 1 || S[i] == T[j]){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
        	&lt;span class=&quot;c1&quot;&gt;// 指针各自右移一位&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 发生了失配，查Next数组移动模式串指针&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 如果模式串指针溢出了（模式串指针匹配完毕了所有模式串中的元素）&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;next&quot;&gt;Next&lt;/h3&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// T 模式串， next Next数组&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 约定索引起始值为1&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SString&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// i 计算每一个元素Next值的指针，它只可能右移用于计算下一个元素的Next值&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// j 用于指向 无法找到头尾串时 的递归回溯的元素 &lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 初始化第一个元素的Next值&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 如果递归回溯到第一个元素，它的next值为0，就无法继续回溯 -&amp;gt; 下一位元素的 Next值 就会等于 第一个元素的索引（1 即 0 + 1）&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 如果 当前元素 等于 当前元素Next值对应的元素 -&amp;gt; 下一个元素的 Next值 就会等于 当前元素的Next值 + 1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 否则递归回溯j，将其指向更小的一个同首尾的子串的尾部 + 1&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;nextval&quot;&gt;Nextval&lt;/h3&gt;

&lt;p&gt;(以下的讨论假设不需要递归以简化讨论过程)&lt;/p&gt;

&lt;p&gt;优化Next，当第&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i+1&lt;/code&gt;位失配的时候。通常，我们按照算法会比较 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T[i]&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T[next[i]]&lt;/code&gt;，若它们相同则将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Next[i+1]&lt;/code&gt;设置成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Next[i] + 1&lt;/code&gt;。但是，如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T[Next[i] + 1]&lt;/code&gt;和失配元素（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T[i+1]&lt;/code&gt;）相同时，这样设置则是多余的（Next元素的含义就是，某个元素失配时用哪个元素补充匹配，若补充匹配的元素和失配元素相同则这样设置是多余的）。所以，此时应该把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Next[i+1]&lt;/code&gt;设置成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Next[Next[i] + 1]&lt;/code&gt;，就是当&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Next[i]+1&lt;/code&gt;失配时应该用哪个元素补充匹配。&lt;/p&gt;

&lt;p&gt;那为什么&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T[Next[Next[i] + 1]]&lt;/code&gt;不会等于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T[i+1]&lt;/code&gt;呢？因为按照这样的算法&lt;strong&gt;递推&lt;/strong&gt;是从第一个元素开始计算，可以确保除了当前失配的元素以外，&lt;strong&gt;之前的任意一个元素（索引为m）&lt;/strong&gt;都不可能等于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T[Next[m]+1]&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// T 模式串， next Next数组&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 约定索引起始值为1&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_nextval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SString&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// i 计算每一个元素Next值的指针，它只可能右移用于计算下一个元素的Next值&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// j 用于指向 无法找到头尾串时 的递归回溯的元素 &lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 初始化第一个元素的Next值&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 如果递归回溯到第一个元素，它的next值为0，就无法继续回溯 &lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 如果 当前元素 等于 当前元素Next值对应的元素 &lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]){&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 如果替补匹配的值不等于当前失配值,则设置它的索引为Next值&lt;/span&gt;
	            &lt;span class=&quot;n&quot;&gt;nextval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 否则设置它的Next值为当前失配值的Next值&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;nextval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 否则递归回溯j，将其指向更小的一个同首尾的子串的尾部 + 1&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;如果还是不能看懂Next数组的程序实现，推荐自己手动制作一下下图Next数组算法的逐帧动画，会帮助理解很多。&lt;/p&gt;

&lt;center&gt;&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/KMP/next.gif&quot; /&gt;&lt;/div&gt;&lt;/center&gt;
 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-05-09T00:00:00+08:00&quot;&gt;
                2019-05-09
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Thu, 09 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/09/KMP/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/09/KMP/</guid>
        
        <category>数据结构</category>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>数据结构（五）：串的C++实现</title>
        
        
        <description> 
&lt;p&gt;本文使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;实现了严蔚敏老师«数据结构»中的抽象数据类型&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;字符串&lt;/code&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;script src=&quot;https://gist.github.com/eMous/d0e303a059d398b6142cbf382a84f4ef.js&quot;&gt;&lt;/script&gt;

 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-05-08T00:00:00+08:00&quot;&gt;
                2019-05-08
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Wed, 08 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/08/DataStructure_String_C++/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/08/DataStructure_String_C++/</guid>
        
        <category>C++</category>
        
        
        <category>数据结构</category>
        
      </item>
    
      <item>
        <title>数据结构（六）：栈的C++实现</title>
        
        
        <description> 
&lt;p&gt;本文使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;实现了严蔚敏老师«数据结构»中的抽象数据类型&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;栈&lt;/code&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;script src=&quot;https://gist.github.com/eMous/0935da2b56361ddecbb8d0b6612c5b3d.js&quot;&gt;&lt;/script&gt;

 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-05-08T00:00:00+08:00&quot;&gt;
                2019-05-08
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Wed, 08 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/08/DataStructure_Stack_C++/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/08/DataStructure_Stack_C++/</guid>
        
        <category>C++</category>
        
        
        <category>数据结构</category>
        
      </item>
    
      <item>
        <title>记录</title>
        
        
        <description> &lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;循环队列，循环栈..“循环xx”的概念之所以会出现，有一个重要的原因或者说理念就是————避免“开辟新的存储空间这一过程”而造成的性能开销和管理负担，就和线程池这一概念类似。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模板方法的实现需要定义在头文件里，常量的定义也能定义在头文件里，然而普通函数的实现不能定义在头文件里哪怕有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ifndef&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T *const foo&lt;/code&gt; foo is a &lt;strong&gt;const point&lt;/strong&gt; to T
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T const *foo&lt;/code&gt; foo is a point to &lt;strong&gt;const T&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;绝大多数现代语言的对象都是指针或者说引用：&lt;/p&gt;

    &lt;p&gt;像一根引线一样将数据完整得保持并穿梭在各调用栈间，再依靠面向对象自身的范式以及语言运行时的回收机制给用户提供一种“’语言的使用’本身以及和机器实现近乎隔绝”的体验。&lt;/p&gt;

    &lt;p&gt;尤其是“内存存储”这一概念很好的被引用类型、面向对象以及运行时回收机制等现代语言的相关特性隐藏，语言的用户只管“用”就行。当用户不再能通过&lt;strong&gt;当前上下文&lt;/strong&gt;配合&lt;strong&gt;相关语言规则（比如用户不在显式的可达某个资源的’符号’时）&lt;/strong&gt;获取到相关资源时，它又将定期得被（或许是依附的）运行时程序回收管理。&lt;/p&gt;

    &lt;p&gt;而C++相比于它们就赤裸且又丰富很多：&lt;/p&gt;

    &lt;p&gt;一方面它并不如同绝大多数的现代语言——用引用的方式将符号和实在隔绝开，仅允许用户通过引用操纵实在。C++中几乎所有都是实际存在，如果没有特殊的手段，那看见的符号就一定代表（evaluate）着一个有实际意义的真实存在。&lt;/p&gt;

    &lt;p&gt;一方面单单其他现代语言中的引用功能在C++中就有多个效果相同实现却不同的版本，最近似的是“指针”但是它却其他现代语言多了可以被直接解释的语义——它不仅仅为了“关联”一个遥远的“实际存在”而存在（这是绝大多数现代语言关于引用类型在语言中扮演的角色的“基本上仅有的”阐释），它还能被解读出“其本身也是‘实际存在’，而用户可以通过不同的操作来对这两个不同的存在进行控制”的含义，更丰富得，还有“‘关联’这一行为对于用户而言在C++中并不是透明的，这意味着：用户可以通过语言的操控实现‘关联’的解除，重建乃至切换”当然也正是这导致了那个遥远的存在变得真正的遥远而无法触及。&lt;/p&gt;

    &lt;p&gt;另一个带有相同“引用功能”的特性就是“引用”，通过引用用户可以使用一种语言提供的强制的特性“让编译器将多个不同的符号解读成相同的实在”，就是别名，另一个名字。甚至，可以通过创建别名的方式将实在在调用栈中穿梭。如果把指针类型的引用形式描述成“在层层戒严包围的监狱使用电话号码联系外部自由的朋友帮忙”那引用类型则是直接的“复仇者联盟中的‘星云’——哪怕是从未来穿越回到现在，哪怕确确实实当下有两个一模一样的人，它们却有着完全相同的内在意识”。&lt;/p&gt;

    &lt;p&gt;所以C++像极了瑞士军刀，繁杂且锋利，若不是相当熟悉你便难以明白应该使用哪一种特性去更高效地编码以及更高效的运行；同时稍有不慎又容易划伤自己，自乱阵脚，陷入频繁的查错之中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数组和广义表并不是包含关系，数组的定义里就确定了维度，因此它可以基于顺序结构实现也可以基于链式结构实现。但是广义表的定义是基于递归的，它可以表示一个更宽广的范围，因此他只能通过链式结构实现。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-05-05T00:00:00+08:00&quot;&gt;
                2019-05-05
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Sun, 05 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/05/Note/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/05/Note/</guid>
        
        
        <category>SSH</category>
        
      </item>
    
      <item>
        <title>数据结构（四）：链队列的C++实现</title>
        
        
        <description> 
&lt;p&gt;本文使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;实现了严蔚敏老师«数据结构»中的抽象数据类型&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;队列&lt;/code&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;script src=&quot;https://gist.github.com/eMous/0d16a1c3c6bcf9bfcf4c1beed38e240d.js&quot;&gt;&lt;/script&gt;

 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-05-05T00:00:00+08:00&quot;&gt;
                2019-05-05
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Sun, 05 May 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/05/DataStructure_Queue_C++/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/05/DataStructure_Queue_C++/</guid>
        
        <category>C++</category>
        
        
        <category>数据结构</category>
        
      </item>
    
      <item>
        <title>重新认识SSH（一）</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#环境介绍&quot; id=&quot;markdown-toc-环境介绍&quot;&gt;环境介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#版本交换&quot; id=&quot;markdown-toc-版本交换&quot;&gt;版本交换&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#二进制包协议&quot; id=&quot;markdown-toc-二进制包协议&quot;&gt;二进制包协议&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#密钥交换&quot; id=&quot;markdown-toc-密钥交换&quot;&gt;密钥交换&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#dh&quot; id=&quot;markdown-toc-dh&quot;&gt;DH&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ecdh&quot; id=&quot;markdown-toc-ecdh&quot;&gt;ECDH&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#curve25519&quot; id=&quot;markdown-toc-curve25519&quot;&gt;curve25519&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#服务端认证&quot; id=&quot;markdown-toc-服务端认证&quot;&gt;服务端认证&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#客户端认证&quot; id=&quot;markdown-toc-客户端认证&quot;&gt;客户端认证&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#扩展协商&quot; id=&quot;markdown-toc-扩展协商&quot;&gt;扩展协商&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#server-sig-algs&quot; id=&quot;markdown-toc-server-sig-algs&quot;&gt;server-sig-algs&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#delay-compression&quot; id=&quot;markdown-toc-delay-compression&quot;&gt;delay-compression&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#no-flow_control&quot; id=&quot;markdown-toc-no-flow_control&quot;&gt;no-flow_control&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#elevation&quot; id=&quot;markdown-toc-elevation&quot;&gt;elevation&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#公钥认证&quot; id=&quot;markdown-toc-公钥认证&quot;&gt;公钥认证&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#公钥类型&quot; id=&quot;markdown-toc-公钥类型&quot;&gt;公钥类型&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#publickkey公钥认证方法&quot; id=&quot;markdown-toc-publickkey公钥认证方法&quot;&gt;publickkey公钥认证方法&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#rsa-sha2-256&quot; id=&quot;markdown-toc-rsa-sha2-256&quot;&gt;rsa-sha2-256&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#traffic-analysis&quot; id=&quot;markdown-toc-traffic-analysis&quot;&gt;traffic analysis&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#密码认证&quot; id=&quot;markdown-toc-密码认证&quot;&gt;密码认证&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#host-based认证&quot; id=&quot;markdown-toc-host-based认证&quot;&gt;Host-Based认证&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#keyboard-interactive认证&quot; id=&quot;markdown-toc-keyboard-interactive认证&quot;&gt;keyboard-interactive认证&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#小结&quot; id=&quot;markdown-toc-小结&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#reference&quot; id=&quot;markdown-toc-reference&quot;&gt;Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/SSH/SSH_logo.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;自从我尝试使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Public Key Authentication&lt;/code&gt;登陆ssh，我本就应该做好要把SSH所有的rfc都看完的打算的，在本篇文章中我将尽可能详细地阐明我对&lt;strong&gt;密码学如何在ssh中使用&lt;/strong&gt;的认识。:C&lt;/p&gt;

&lt;p&gt;按照&lt;a href=&quot;https://tools.ietf.org/html/rfc4251&quot;&gt;SSH协议架构&lt;/a&gt;，标准将SSH分成三层：传输层协议、用户认证协议、连接协议。最底层的是传输层协议，它负责&lt;strong&gt;认证服务器&lt;/strong&gt;，&lt;strong&gt;加密数据&lt;/strong&gt;，&lt;strong&gt;确保数据完整性&lt;/strong&gt;，虽然它运行在TCP之上，但其实它可以运行在&lt;strong&gt;任意可靠&lt;/strong&gt;的数据流之上；第二次是用户认证协议，它负责&lt;strong&gt;认证使用者是否是ssh服务器的用户&lt;/strong&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Public Key Authentication&lt;/code&gt;登陆ssh就将在这一层实现；最上层是连接协议，它将把&lt;strong&gt;多路加密的通道&lt;/strong&gt;转换成&lt;strong&gt;逻辑上的Channel&lt;/strong&gt;。本文将主要描述前两层协议。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;环境介绍&quot;&gt;环境介绍&lt;/h2&gt;

&lt;p&gt;我的Host机器是使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenSSH_7.4p1&lt;/code&gt;的 CentOS 7,而Client机是使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenSS_7.9p1&lt;/code&gt;的macOS，因此我会尽可能的使用新的SSH标准进行阐述。&lt;/p&gt;

&lt;h2 id=&quot;版本交换&quot;&gt;版本交换&lt;/h2&gt;

&lt;p&gt;下图是我使用wireshark抓取到的SSH登陆过程中往返的数据包，&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/SSH/wireshark.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;可以发现，最开始的由客户端发起的一个往返数据包，它用于交换客户端和服务器SSH版本信息。其中第一个数字，是SSH版本信息，第二个则是软件版本信息。关于服务器和客户端版本不匹配的问题，如果是服务器则可以设置兼容模式（enables compatibility）来自动应对低版本的客户端，而客户端遇到低版本的服务器必须断开连接后手动切换版本（这是因为协议没有约束客户端必须等到服务器的回应再发出命令，这就意味着可能客户端会先发出其他命令从而把旧的协议占用）。&lt;/p&gt;

&lt;h2 id=&quot;二进制包协议&quot;&gt;二进制包协议&lt;/h2&gt;

&lt;p&gt;大概率是因为要解决&lt;strong&gt;TCP粘包&lt;/strong&gt;以及&lt;strong&gt;长度整除密钥方便处理&lt;/strong&gt;的问题，在版本交换后SSH都必须以&lt;strong&gt;二进制包协议&lt;/strong&gt;的格式进行传输。&lt;/p&gt;

&lt;pre&gt;
                                  payload
                 [byte[packet_length - padding_length - 1]]
                                     ^
                                     |
       packet_length                 |             mac (Message Authentication Code - MAC)
          [uint32]                   |                        [byte[mac_length]]
             ^                       |                                ^
             |                       |                                |
             |                       |                                |
+-------+--------------------------------------------------------------------+
|       |    |                       |   ssh                          |      |
|       | +-----+---+--------------------------------+----------+----------+ |
|       | |  |  |   |                |               |          |     |    | |
|       | |  |  |   |                |               |          |     |    | |
|  tcp  | |  |  |   |                |               |          |     |    | |
|       | |  +  | + |                +               |    +     |     +    | |
|       | |     | | |                                |    |     |          | |
|       | |     | | |                                |    |     |          | |
|       | +----------------------------------------------------------------+ |
+-------+--------------------------------------------------------------------+
                  |                                       |
                  |                                       |
                  |                                       |
                  v                                       v
               [byte]                           [byte[padding_length]]
            padding_length                          random padding

&lt;/pre&gt;
&lt;p&gt;其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;random padding&lt;/code&gt;用于补全长度，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;payload&lt;/code&gt;为有效负载，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mac &lt;/code&gt;为消息认证码。所以单个packet是有最大长度的，未压缩的包大小必须小于35000字节。&lt;/p&gt;

&lt;p&gt;若压缩算法协商成功，&lt;strong&gt;payload&lt;/strong&gt;区域将被压缩，&lt;strong&gt;packet_length&lt;/strong&gt;、&lt;strong&gt;mac&lt;/strong&gt;区域将被重新计算。&lt;strong&gt;加密将在压缩之后执行。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在密钥交换成功之后，一个加密密钥将会被计算出来。之后，&lt;strong&gt;packet length&lt;/strong&gt;、&lt;strong&gt;padding length&lt;/strong&gt;、&lt;strong&gt;payload&lt;/strong&gt;、&lt;strong&gt;random padding&lt;/strong&gt;将必须被加密。同时，两个方向的加密算法可以被允许是不相同的。&lt;/p&gt;

&lt;p&gt;当密钥交换完毕后，会有一个&lt;strong&gt;消息认证码算法&lt;/strong&gt;被协商出，这是一个给定输出长度mac的摘要算法MAC，之后运算 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mac = MAC(shared secret, packet sequence number, entire unencrpyted packet without &apos;mac&apos;)&lt;/code&gt;。packet sequence number是一个隐性的数字，它从第一个packet开始以0计算，每2^32次后又重新开始，不受&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;密钥再协商&lt;/code&gt;协议的影响。由于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shared secret&lt;/code&gt;只有双方知晓，且双方都能认证对方（或者，在shell登陆前server并不需要对client进行认证）因此可以确保这个消息并不来自于第三方；由于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;packet sequence number&lt;/code&gt;是同步于双方的，因此确保这个消息是有序的；最后再把完整的未加密packet放在一起运算，可以保证消息的完整性。&lt;/p&gt;

&lt;h2 id=&quot;密钥交换&quot;&gt;密钥交换&lt;/h2&gt;

&lt;p&gt;密钥交换(Key Exchange)是SSH中紧接着的第二步，它最直接的目的有两个：&lt;strong&gt;用一个安全的方式将接下来的packet加密密钥传到双方手中&lt;/strong&gt;、&lt;strong&gt;让客户端相信“同时获得密钥的另一个人”就是千真万确的服务器&lt;/strong&gt;。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/SSH/key_exchange.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;第一步，客户端在payload中表明&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Message Code = 20(Key Exchange Init)&lt;/code&gt;,并毫无保留的把自己支持的各种加密算法告诉服务器，同时猜测服务器支持哪些算法。需要提供的算法类型（算法用途）有&lt;strong&gt;密钥交换算法&lt;/strong&gt;，&lt;strong&gt;用于认证服务器的公钥属于什么公钥算法&lt;/strong&gt;，&lt;strong&gt;客户端-&amp;gt;服务端的数据加密使用什么算法&lt;/strong&gt;，&lt;strong&gt;服务端-&amp;gt;客户端的数据加密使用什么算法&lt;/strong&gt;，&lt;strong&gt;客户端-&amp;gt;服务端的数据使用什么MAC算法&lt;/strong&gt;，&lt;strong&gt;服务端-&amp;gt;客户端的数据使用什么MAC算法&lt;/strong&gt;，&lt;strong&gt;客户端-&amp;gt;服务端的数据使用什么压缩算法&lt;/strong&gt;，&lt;strong&gt;服务端-&amp;gt;客户端的数据使用什么压缩算法&lt;/strong&gt;。同时还要提供和估测，客户端到服务端的数据使用何种语言，服务端到客户端的数据使用何种语言；first_kex_packet_follows表示是否要先在服务器提供他的列表并得出协商结果前直接尝试一次客户端自己猜测的交换算法，如果设为true，客户端会在收到消息之前就发出初始化交换算法的请求，如果猜错了服务端会直接无视；一个&lt;strong&gt;随机数cookie&lt;/strong&gt;（它将被用来生成session_id,同时确保双方中的任意一方没有完全的能力控制其初始化的结果）；一个暂未定义的数据项。&lt;/p&gt;

&lt;p&gt;第二部，服务端把自己的算法列表公布给客户端。同时双方根据某种约定好的协商机制（大体上就是，选双方都有的，选第一个），再之后就由客户端开始双方协商好的密钥交换算法。&lt;/p&gt;

&lt;p&gt;进行完密钥交换算法后，双方都一定会得到两个输出结果：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个&lt;strong&gt;仅（它甚至都不曾在链路中出现）&lt;/strong&gt;共享在双方间的秘密（shared secret）K。&lt;/li&gt;
  &lt;li&gt;一个交换摘要（exchange hash）H，并且约定在第一次密钥交换中得到的H即为&lt;strong&gt;session_id&lt;/strong&gt;（它能唯一确定当前的连接）它被用来标记一个真正拥有服务端私钥的证据。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后双方协商，通过这两个数据和一些约定的公共数据（硬编码在协议里），使用&lt;strong&gt;密钥交换摘要算法&lt;/strong&gt;生成各上述的用作各种用途的确切密钥。&lt;/p&gt;

&lt;h3 id=&quot;dh&quot;&gt;DH&lt;/h3&gt;

&lt;p&gt;DH(Diffie-Hellman Key Exchange)算法是历史上的第一个密钥交换算法，只有双方都参与才能生成shared secret。同时，交换完成时它将从服务器返回3个数据。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;host key&lt;/li&gt;
  &lt;li&gt;f&lt;/li&gt;
  &lt;li&gt;signature of HASH(client_id,server_id,payload of client’s SSH_MSG_KEXINIT,payload of server’s SSH_MSG_KEXINIT,&lt;strong&gt;host_key&lt;/strong&gt;, e, f, K)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过，df算法可以将客户端提供的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;和服务端提供的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;再配合之前获取的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GROUP&lt;/code&gt;生成秘密的shared_secret K。因此如果在HASH中有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;host_key&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt;同时作为参数，若hash匹配则能证明host key确实是协商者提供的，再之后则只需要验证host_key的确有来自于&lt;strong&gt;host&lt;/strong&gt;的权威性就行了。&lt;/p&gt;

&lt;p&gt;下图是DH交换算法在SSH协议中的流程（KEXINIT）。&lt;/p&gt;
&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/SSH/sshtrans.jpg&quot; /&gt;&lt;/div&gt;

&lt;h3 id=&quot;ecdh&quot;&gt;ECDH&lt;/h3&gt;

&lt;p&gt;ECDH(Elliptic Curve Diffie Hellman)椭圆曲线DH，它是基于ECC的交换算法。对于交换算法本身而言，它和DH类似，它需要提供的协商的参数包括&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(p,a,b,G,n,h) &lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;它的一般交换流程如下：&lt;/p&gt;

&lt;pre&gt;
      Client                                                Server
      ------                                                ------
      Generate ephemeral key pair.
      SSH_MSG_KEX_ECDH_INIT  --------------&amp;gt;

                                      Verify received key is valid.
                                       Generate ephemeral key pair.
                                             Compute shared secret.
                                   Generate and sign exchange hash.
                             &amp;lt;------------- SSH_MSG_KEX_ECDH_REPLY

&lt;/pre&gt;
&lt;p&gt;可以发现，有一些步骤对于它而言是必须的：~&lt;del&gt;协商公共参数&lt;/del&gt;~，生成各自的keypair并提交公钥，各自验证对方提供的公钥。&lt;/p&gt;

&lt;h3 id=&quot;curve25519&quot;&gt;curve25519&lt;/h3&gt;

&lt;p&gt;也是机缘巧合，因为我的机器就使用的是这个算法（其实也是因为更新的rfc强制要求默认使用这个算法）。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;A new set of Elliptic Curve Diffie-Hellman ssh-curves exist.  The
   curve25519-sha256 MUST be adopted where possible.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我发现wireshark抓包后，尽然直截了当的仅仅不可思议的两步就完成了密钥交换：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端提供&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;服务器提供&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/SSH/curve25519.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;一直很纳闷那之前说的那个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g&lt;/code&gt;去哪了？还有那些要协商的各种参数又去哪了？怎么你来我往一下直接就生成shared secret了？&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/SSH/curve25519_1.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;但其实并不是，他们都”pre install”了，作者找到了一个很Special但并不可疑的特定的曲线curve25519，在这个曲线中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g[32] = {9}&lt;/code&gt;。因此，使用他，DH的流程可以更加简化。&lt;/p&gt;

&lt;pre&gt;
Client                                                            Server
------                                                            ------
Generate ephemeral key pair.
SSH_MSG_KEX_ECDH_INIT          --------&amp;gt;                      
                                            Verify that client public key 
                                            length is 32 bytes.
                                             Generate ephemeral key pair.
                                                   Compute shared secret.
                                         Generate and sign exchange hash.
                               &amp;lt;--------           SSH_MSG_KEX_ECDH_REPLY
Verify that server public key length is 32 bytes.
* Verify host keys belong to server.
Compute shared secret.
Generate exchange hash.
Verify server&apos;s signature.
&lt;/pre&gt;

&lt;p&gt;其作者在论文中写到，这个算法有着&lt;strong&gt;极致的速度&lt;/strong&gt;、&lt;strong&gt;免疫timing attack&lt;/strong&gt;、&lt;strong&gt;提供短的secret keys&lt;/strong&gt;、&lt;strong&gt;只需要32字节的public key&lt;/strong&gt;、&lt;strong&gt;只要32字节的输入都是合法的，不需要验证&lt;/strong&gt;、&lt;strong&gt;程序代码简短&lt;/strong&gt;的优点。&lt;/p&gt;

&lt;h2 id=&quot;服务端认证&quot;&gt;服务端认证&lt;/h2&gt;

&lt;p&gt;诚如SSH RFC所说，由于SSH早于TSL问世，哪怕它已经解决了可绝大多数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;telnet&lt;/code&gt;会遇到的安全问题，它依旧面对一些情况依旧会遇到安全隐患。比如，初次建立SSH连接时可能会遇到的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;中间人攻击&lt;/code&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The protocol provides the option that the server name - host key
   association is not checked when connecting to the host for the first
   time.  This allows communication without prior communication of host
   keys or certification.  The connection still provides protection
   against passive listening; however, it becomes vulnerable to active
   man-in-the-middle attacks.  Implementations SHOULD NOT normally allow
   such connections by default, as they pose a potential security
   problem.  However, as there is no widely deployed key infrastructure
   available on the Internet at the time of this writing, this option
   makes the protocol much more usable during the transition time until
   such an infrastructure emerges, while still providing a much higher
   level of security than that offered by older solutions (e.g., telnet
   &lt;a href=&quot;https://tools.ietf.org/html/rfc0854&quot;&gt;RFC0854&lt;/a&gt; and rlogin &lt;a href=&quot;https://tools.ietf.org/html/rfc1282&quot;&gt;RFC1282&lt;/a&gt;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然而，绝大多数情况SSH还是可以提供安全可靠的服务端认证的。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/SSH/server_auth.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;具体格式如下（DH）：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The hash H is computed as the HASH hash of the concatenation of the following:
      string    V_C, the client&apos;s identification string (CR and LF
                excluded)
      string    V_S, the server&apos;s identification string (CR and LF
                excluded)
      string    I_C, the payload of the client&apos;s SSH_MSG_KEXINIT
      string    I_S, the payload of the server&apos;s SSH_MSG_KEXINIT
      string    K_S, the host key
      mpint     e, exchange value sent by the client
      mpint     f, exchange value sent by the server
      mpint     K, the shared secret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;所以说，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MITM&lt;/code&gt;只可能发生在第一次认证服务器的时候，这个时候客户端或许不能确认host key的真实身份。而之后，host key一定是被保障的，中间人也一定无法用被保障的private key签名。（其实也是存在一种可能的，就是某个受信任的host充当中间人的角色），引用一段我觉得很精彩的&lt;a href=&quot;https://security.stackexchange.com/questions/39608/if-a-mitm-has-your-public-key-and-you-are-ssh-ing-through-the-mitm-what-is-the&quot;&gt;论述&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;All of this relies on the magic of asymmetric cryptography:
    You can verify a signature with the public key, but producing new signatures requires knowledge of the private key, and the private key cannot be (practically) deduced from the public key.
    The DH key exchange consists in publicly exchanged messages, sender and receiver finally agree on a “shared secret” obtained by processing these messages, and yet someone observing only these messages cannot recompute the same secret.
    Mathematics are involved.        @Thomas Pornin&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;客户端认证&quot;&gt;客户端认证&lt;/h2&gt;

&lt;p&gt;认证完服务器后，紧接着客户端就会发送一个New key(SSH_MSG_NEWKEYS21)表明接下来要使用对称加密进行通信了。之后，wireshark就无法抓取到可读包裹了，只能通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh -vvv&lt;/code&gt;选项学习理解。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/SSH/client_auth.png&quot; /&gt;&lt;/div&gt;

&lt;h3 id=&quot;扩展协商&quot;&gt;扩展协商&lt;/h3&gt;

&lt;p&gt;在讨论客户端认证流程之前必须提及2018年4月更新的关于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;扩展协商&lt;/code&gt;的相关标准，它提供了一种机制去帮助客户端和服务器在密钥交换完成之后，秘密地交换各自的扩展。这个标准制定的主要原因，是因为&lt;strong&gt;SSH在原本的设计中没有一个良好的机制去确认服务端支持何种公钥认证机制，尤其是当RSA with SHA-256、SHA-512被广泛使用以后&lt;/strong&gt;，如果没有一个良好的扩展协商机制，就无法避免客户端再认证时候的尝试与错误，以及认证错误的惩罚。&lt;/p&gt;

&lt;p&gt;标准规定，支持扩展协商的客户端和服务端可以在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;密钥交换初始化&lt;/code&gt;过程中，将自己&lt;strong&gt;支持扩展交换&lt;/strong&gt;这个机制以一种&lt;strong&gt;加密算法&lt;/strong&gt;的形式写如各自的算法列表（如果他们希望知道对方的扩展）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务端写入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ext-info-s&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;客户端写入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ext-info-c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样做有两个好处：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可以知道对方是否支持&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;扩展协商&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;而这个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;扩展协商&lt;/code&gt;因为双方各自表示的不同，自然地不可能被当作加密算法被使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同时，双方一旦标注&lt;strong&gt;自己支持扩展协商&lt;/strong&gt;，就必须做好被对方使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_EXT_INFO &lt;/code&gt;packet告知其扩展信息的准备。同时，这个&lt;strong&gt;告知对方自身扩展信息&lt;/strong&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_EXT_INFO &lt;/code&gt;packet，对使用顺序有明确的规定。
如果由客户端发送自身扩展信息则必须满足一个条件：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;这个packet是紧接着客户端的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_NEWKEYS&lt;/code&gt;发送的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果由服务端发送自身扩展信息则必须满足以下任意一个条件：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;这个packet是紧接着服务端的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_NEWKEYS&lt;/code&gt;的。 因为客户端需要这个扩展信息来进行认证处理，所以它应该尽可能快的发送过去（紧接着&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_NEWKEYS&lt;/code&gt;）.&lt;/p&gt;

    &lt;p&gt;但是客户端不能指望必须有这个消息，因为服务端发送这个消息并不是被要求的。同时，由于网络延迟，客户端可能已经请求了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_SERVICE_REQUEST&lt;/code&gt;，并开启了之后的认证协议的过程，但是如果及时送达，那客户端就可以在这个基础上进行认证。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在准备发送服务端的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_USERAUTH_SUCCESS&lt;/code&gt;之前立马发送。&lt;/p&gt;

    &lt;p&gt;这是服务器第二次发送的机会，不论它是否在条件1发送过。标注了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ext-info-c&lt;/code&gt;的客户端都必须接受服务端的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_USERAUTH_SUCCESS&lt;/code&gt;不论是来自于哪一个条件的发送，但是客户端不准期待（要求）服务器总是会发送它（可能服务器并不支持这个扩展交换的标准）。&lt;/p&gt;

    &lt;p&gt;这使得服务器可以发送一些不愿意公布给未认证的客户端的扩展信息。如果，服务器发送了第二种情况的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_EXT_INFO&lt;/code&gt;，它将取代所有的第一次发送的扩展，服务器和客户端需要重新计算使得扩展生效。服务器的第二次发送，同样匹配客户端的第一次发送。&lt;/p&gt;

    &lt;p&gt;标准决定第二次发送在这样的时机下是由于以下的原因：如果这个消息过早得发送，服务器无法保留住必要的信息在客户端被认证之前。如果它稍晚德发送，确实需要这个第二次信息地客户端在他被认证之后将没有一个可靠的方法去知道是否要期待（等待）这个消息。扩展的生效时间需要被明确指出，而扩展必须和其陈列的顺序无关。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;server-sig-algs&quot;&gt;server-sig-algs&lt;/h4&gt;

&lt;p&gt;这个扩展只允许存在在服务端中，它包含&lt;strong&gt;服务端支持的所有公钥认证算法列表&lt;/strong&gt;，早期的一些SSH服务器或许没有提供&lt;strong&gt;所有&lt;/strong&gt;的算法。&lt;/p&gt;

&lt;p&gt;一个希望使用公钥认证的客户端&lt;strong&gt;或许&lt;/strong&gt;可以等待来自服务端的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_EXT_INFO&lt;/code&gt;,这样他就能提交合适的公钥，而不是试错。同时，支持了公钥认证的SSH服务器&lt;strong&gt;应该&lt;/strong&gt;支持这一扩展。&lt;/p&gt;

&lt;p&gt;如果客户端没有发送这个扩展，客户端&lt;strong&gt;不准&lt;/strong&gt;做出服务端支持任何算法的假设，而是应该试错，同时这些实现必须知道他们提供错误的公钥算法的公钥进行认证会受到惩罚。&lt;/p&gt;

&lt;p&gt;认证惩罚由服务器发出，用来阻止&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;暴力密码猜测&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;用户名枚举&lt;/code&gt;和一些其他的被程序实现者或服务器管理员认为有嫌疑的行为类型。惩罚或许会包括&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IP限流或制止&lt;/code&gt;，这些惩罚或许会触发服务器的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;邮件提醒&lt;/code&gt;或&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;审计记录&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;delay-compression&quot;&gt;delay-compression&lt;/h4&gt;

&lt;p&gt;它的extension-value包含两个算法列表：c-&amp;gt;s的列表和s-&amp;gt;c的列表。这个扩展的意义在于，它允许客户端和服务端直接的协商压缩算法，而不需要发起一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key re-exchange&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这个扩展只有在双方都发送的时候才生效，名称列表&lt;strong&gt;或许&lt;/strong&gt;会包含在算法协商时可以被采纳的算法，除了那些自定义的算法（因此只允许标准定义的算法）。比如说：’zlib,none’时一个符合规范的名称列表，但是’zlib@openssh.com’却不是。&lt;/p&gt;

&lt;p&gt;如果双方都发送了这个扩展，且找不到共同的算法，则使用如同协商失败一样的方式断开连接。如果生效，则在每一端的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;触发消息&lt;/code&gt;之后都将使用新的压缩算法：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;来自服务端方向的packet，在发送&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_USERAUTH_SUCCESS&lt;/code&gt;之后。&lt;/li&gt;
  &lt;li&gt;来自客户端方向的packet，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_NEWCOMPRESS&lt;/code&gt;之后。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果扩展生效，客户端&lt;strong&gt;必须&lt;/strong&gt;在收到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_USERAUTH_SUCCESS&lt;/code&gt;后的合理数目的发出消息后发送&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_NEWCOMPRESS&lt;/code&gt;消息，它并不要求是之后的第一个消息。&lt;/p&gt;

&lt;p&gt;这样做的原因是为了避免触发&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;race condition(竞争条件)&lt;/code&gt;——服务器无法可靠的知道来自客户端的消息是它收到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_USERAUTH_SUCCESS&lt;/code&gt;之前或是之后的。比如在登陆期间，客户端可能会发送&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;keep-alive&lt;/code&gt;消息。和其他的扩展一样，除非另有说明，服务器会直到第二次发送&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_EXT_INFO&lt;/code&gt;并且在发送&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_USERAUTH_SUCCESS&lt;/code&gt;之前才启用扩展。这也使得服务端可以避免在客户端被认证前花费算力使用压缩。&lt;/p&gt;

&lt;p&gt;当各方重新协商压缩算法且又正在使用这一扩展时，如果重新协商的压缩算法在一个或连两个方向上没有改变，一旦重新协商的算法生效，内部的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;压缩状态&lt;/code&gt;也必须在每个方向上被重置。&lt;/p&gt;

&lt;p&gt;由于这个扩展的时间区间可能会和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Key Re-Exchange&lt;/code&gt;发生冲突，标准做出规定&lt;strong&gt;对于已经声明扩展，或将要声明扩展&lt;/strong&gt;的一方&lt;strong&gt;禁止&lt;/strong&gt;初始化&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Key Re-Exchange&lt;/code&gt;直到下面的情况有一项满足：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;扩展已经协商完成，并且这希望开始rekey的一方已经发送了它的上文所述的trigger message。&lt;/li&gt;
  &lt;li&gt;这一方（如果是服务器）已经发送或者（如果是客户端）接收了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_USERAUTH_SUCCESS&lt;/code&gt;且扩展没有协商成功。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;no-flow_control&quot;&gt;no-flow_control&lt;/h4&gt;

&lt;p&gt;这个扩展有两个值可选：’p’代表推荐的，’s’表示支持的。它只有在双方都提供扩展且至少有一方为’p’时才生效。&lt;/p&gt;

&lt;p&gt;如果扩展生效，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_CHANNEL_OPEN&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_CHANNEL_OPEN_CONFIRMATION&lt;/code&gt;packets的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;initial window size&lt;/code&gt;区域将被认为是无意义的，频道将被视作所有的窗口大小都是无穷大的。同时所有接收到的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_CHANNEL_WINDOW_ADJUST&lt;/code&gt;消息也都将被忽略。&lt;/p&gt;

&lt;p&gt;这个扩展是为（但不局限于）文件传输应用而设计的，它们只准备使用一个频道，对于他们而言SSH提供的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;流控&lt;/code&gt;并不是一个功能而是一个阻碍。如果这个扩展生效，实现&lt;strong&gt;必须&lt;/strong&gt;阻止打开超过一个同时的频道，但服务器应该支持客户端打开不止一个非同时的频道。&lt;/p&gt;

&lt;p&gt;标准推荐优先实现这一扩展，在没有这一扩展之前一些应用都会选择不实现流控，而是通过发送一个初始大小为2^32-1字节的频道窗口，标准不建议再这么做因为：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;当传输超过2^32字节的时候是合理的，但是如果另一端实现SSH流控，那么这一端的服务将被挂起。&lt;/li&gt;
  &lt;li&gt;这样的实现无法处理大尺寸的频道窗口，而且它会出现不优雅的行为，包括断开连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;elevation&quot;&gt;elevation&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;elevation&lt;/code&gt;（提升）或者&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;elevated&lt;/code&gt;指的是一种操作系统的机制，这种机制使得管理员登陆的会话可以关联到两个安全上下文：一个受限和一个拥有管理员权限。提升会话就是启用完全的管理员权限（这是Windows的一个机制: &lt;a href=&quot;https://tools.ietf.org/html/rfc8308#ref-WINADMIN&quot;&gt;WINADMIN&lt;/a&gt; 和 &lt;a href=&quot;https://tools.ietf.org/html/rfc8308#ref-WINTOKEN&quot;&gt;WINTOKEN&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;该扩展提供三个选项,’y’、’n’、’d’分别表示提升、不提升、由服务器决定。设计这个扩展的好处是，这可以减少提供SSH登录的Windows服务器的受攻击表面。对于不支持此扩展的客户端，服务端必须提升会话以确保一登录就有完全的管理员权限，否则可以随时提升会话只要客户端发出该请求。&lt;/p&gt;

&lt;h3 id=&quot;公钥认证&quot;&gt;公钥认证&lt;/h3&gt;

&lt;h4 id=&quot;公钥类型&quot;&gt;公钥类型&lt;/h4&gt;

&lt;p&gt;在标准中使用了三个层面去定义公钥的类型：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;公钥格式&lt;/p&gt;

    &lt;p&gt;这个公钥是如何编码的，证书是如何被展现的。在协议中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key blob&lt;/code&gt;或许除了包括公钥外，还会额外包括证书。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;签名、加密算法&lt;/p&gt;

    &lt;p&gt;或许有一些公钥类型既不支持签名也不支持加密。同时，公钥的使用也会被政策条款约束。所以，不同的公钥类型应该被定义应对不同的政策。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;签名或加密数据本身的编码&lt;/p&gt;

    &lt;p&gt;这包括但不限于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;padding&lt;/code&gt;、字节序规定、数据格式等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh-rsa           RECOMMENDED  sign   Raw RSA Key&lt;/code&gt;(初始定义的RSA公钥类型)，它表示ssh-rsa是被推荐使用的公钥类型，它是可签名的，同时它不使用证书而是用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RSA公钥&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh-rsa&lt;/code&gt;是这个公钥类型的标识。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      string    &quot;ssh-rsa&quot;
      mpint     e
      mpint     n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这表示，这个公钥类型的公钥格式符合如下编码：字符串&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh-rsa&lt;/code&gt;紧接着一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mpint&lt;/code&gt;的参数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mpint&lt;/code&gt;的参数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt;。同时&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt;将被用于构建签名的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key blob&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;同时标准规定使用这个公钥格式进行签名和校验需要使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SHA-1 hash&lt;/code&gt;并配合&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RSASSA-PKCS1-v1_5 scheme&lt;/code&gt;。签名的结果将以如下形式编码:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      string    &quot;ssh-rsa&quot;
      string    rsa_signature_blob (该值被编码成一个包含无长度或padding、无符号符合网络字节序的整型的字符串)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;publickkey公钥认证方法&quot;&gt;publickkey公钥认证方法&lt;/h4&gt;

&lt;p&gt;publickey方法是唯一被要求服务端必须实现的认证方法（其他的还包括password、hostbased），在这个认证模型中有私钥权限的一方（若使用publickey进行客户端认证，那这一方就是客户端）必须为认证提供数据。这个方法的大体流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用用户的私钥创建一个签名，并将其发送给服务器。&lt;/li&gt;
  &lt;li&gt;服务器&lt;strong&gt;必须&lt;/strong&gt;确认：
    &lt;ol&gt;
      &lt;li&gt;公钥是否是受信任的。&lt;/li&gt;
      &lt;li&gt;签名是否是有效的。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;如果都满足则必须通过认证，否则必须阻止。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;私钥一般以一种加密的形式存储在客户端，用户必须提供&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;passphrase&lt;/code&gt;解密私钥才能生成签名。即使它们不是这样存储的，签名本身也应该需要涉及一些昂贵的计算。为了避免不必要的处理过程和用户交互，在生成签名前需要提供下面的消息给服务端，&lt;strong&gt;询问使用这个公钥进行公钥认证是否是可被接受的&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_USERAUTH_REQUEST
      string    user name in ISO-10646 UTF-8 encoding [RFC3629]
      string    service name in US-ASCII
      string    &quot;publickey&quot;
      boolean   FALSE
      string    public key algorithm name
      string    public key blob 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果是被接受的（在authorized_keys文件中），服务器则发送如下消息：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_USERAUTH_PK_OK
      string    public key algorithm name from the request
      string    public key blob from the request
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;否则发送 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_USERAUTH_FAILUR&lt;/code&gt;。
之后客户端发送签名数据正式请求认证：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_USERAUTH_REQUEST
      string    user name
      string    service name
      string    &quot;publickey&quot;
      boolean   TRUE
      string    public key algorithm name
      string    public key to be used for authentication
      string    signature
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signature&lt;/code&gt;是&lt;strong&gt;私钥对如下字段进行的签名&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      string    session identifier
      byte      SSH_MSG_USERAUTH_REQUEST
      string    user name
      string    service name
      string    &quot;publickey&quot;
      boolean   TRUE
      string    public key algorithm name
      string    public key to be used for authentication
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;若成功则服务端发送&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_USERAUTH_SUCCESS&lt;/code&gt;；若失败则发送&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_USERAUTH_FAILURE&lt;/code&gt;——客户端继续尝试。&lt;/p&gt;

&lt;h4 id=&quot;rsa-sha2-256&quot;&gt;rsa-sha2-256&lt;/h4&gt;

&lt;p&gt;2018年3月新发布的rfc定义了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rsa-sha2-256&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rsa-sha2-512&lt;/code&gt;算法配合上文所述的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;server-sig-algs&lt;/code&gt;扩展让SSH使用这些算法进行服务端、客户端认证。&lt;/p&gt;

&lt;p&gt;我的设备使用的就是推荐使用的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rsa-sha2-256&lt;/code&gt;，具体的认证请求和上文所述的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh-rsa&lt;/code&gt;基本一致：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     byte      SSH_MSG_USERAUTH_REQUEST
     string    user name
     string    service name
     string    &quot;publickey&quot;
     boolean   TRUE
     string    &quot;rsa-sha2-256&quot;
     string    public key blob:
         string    &quot;ssh-rsa&quot;
         mpint     e
         mpint     n
     string    signature:
         string    &quot;rsa-sha2-256&quot;
         string    rsa_signature_blob
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;同时在标准中还有如下关于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;7.2版本openssh错误&lt;/code&gt;的警告。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;OpenSSH 7.2 (but not 7.2p2) incorrectly encodes the algorithm in the
   signature as “ssh-rsa” when the algorithm in SSH_MSG_USERAUTH_REQUEST
   is “rsa-sha2-256” or “rsa-sha2-512”.  In this case, the signature
   does actually use either SHA-256 or SHA-512.  A server MAY, but is
   not required to, accept this variant or another variant that
   corresponds to a good-faith implementation and is considered safe to
   accept.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;traffic-analysis&quot;&gt;traffic analysis&lt;/h4&gt;

&lt;p&gt;因为加密的原因，这里将根据&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-vvv&lt;/code&gt;与上述标准分析ssh如何执行认证流程。我（主要）根据&lt;a href=&quot;https://tools.ietf.org/html/rfc4250&quot;&gt;The Secure Shell (SSH) Protocol Assigned Numbers&lt;/a&gt;翻阅替换，总结如下。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SSH_MSG_NEWKEYS             21
SSH_MSG_SERVICE_REQUEST     5
SSH_MSG_EXT_INFO            7
SSH_MSG_SERVICE_ACCEPT      6
SSH_MSG_USERAUTH_REQUEST    50
SSH_MSG_USERAUTH_FAILURE    51
SSH_MSG_USERAUTH_SUCCESS    52
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;details&gt;
  &lt;summary&gt;详情&lt;/summary&gt;
  &lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;debug3: send packet: type SSH_MSG_NEWKEYS
debug2: set_newkeys: mode 1
debug1: rekey after 134217728 blocks
debug1: SSH2_MSG_NEWKEYS sent
debug1: expecting SSH2_MSG_NEWKEYS
debug3: receive packet: type SSH_MSG_NEWKEYS
debug1: SSH2_MSG_NEWKEYS received
debug2: set_newkeys: mode 0
debug1: rekey after 134217728 blocks
debug1: Will attempt key: .ssh/openssh_client_key  explicit
debug2: pubkey_prepare: done
debug3: send packet: type SSH_MSG_SERVICE_REQUEST
debug3: receive packet: type SSH_MSG_EXT_INFO
debug1: SSH2_MSG_EXT_INFO received
debug1: kex_input_ext_info: server-sig-algs=&amp;lt;rsa-sha2-256,rsa-sha2-512&amp;gt;
debug3: receive packet: type SSH_MSG_SERVICE_ACCEPT
debug2: service_accept: ssh-userauth
debug1: SSH2_MSG_SERVICE_ACCEPT received
debug3: send packet: type SSH_MSG_USERAUTH_REQUEST
debug3: receive packet: type SSH_MSG_USERAUTH_FAILURE
debug1: Authentications that can continue: publickey
debug3: start over, passed a different list publickey
debug3: preferred publickey,keyboard-interactive,password
debug3: authmethod_lookup publickey
debug3: remaining preferred: keyboard-interactive,password
debug3: authmethod_is_enabled publickey
debug1: Next authentication method: publickey
debug1: Trying private key: .ssh/openssh_client_key
Enter passphrase for key &apos;.ssh/openssh_client_key&apos;: 
debug3: sign_and_send_pubkey: RSA SHA256:A2Puw8wXRCeW8m/4qv/4ybEXzfK+qJOa/C4vZp6xmdI
debug3: sign_and_send_pubkey: signing using rsa-sha2-512
debug3: send packet: type SSH_MSG_USERAUTH_REQUEST
debug2: we sent a publickey packet, wait for reply
debug3: receive packet: type SSH_MSG_USERAUTH_SUCCESS
debug1: Authentication succeeded (publickey).
Authenticated to 192.168.50.81 ([192.168.50.81]:10086).
&lt;br /&gt;
-- connect protocol --
&lt;br /&gt;
debug1: channel 0: new [client-session]
debug3: ssh_session2_open: channel_new: 0
debug2: channel 0: send open
debug3: send packet: type 90
debug1: Requesting no-more-sessions@openssh.com
debug3: send packet: type 80
debug1: Entering interactive session.
debug1: pledge: network
debug3: receive packet: type 80
debug1: client_input_global_request: rtype hostkeys-00@openssh.com want_reply 0
debug3: receive packet: type 91
debug2: channel_input_open_confirmation: channel 0: callback start
debug2: fd 3 setting TCP_NODELAY
debug3: ssh_packet_set_tos: set IP_TOS 0x48
debug2: client_session2_setup: id 0
debug2: channel 0: request pty-req confirm 1
debug3: send packet: type 98
debug2: channel 0: request shell confirm 1
debug3: send packet: type 98
debug2: channel_input_open_confirmation: channel 0: callback done
debug2: channel 0: open confirm rwindow 0 rmax 32768
debug3: receive packet: type 99
debug2: channel_input_status_confirm: type 99 id 0
debug2: PTY allocation request accepted on channel 0
debug2: channel 0: rcvd adjust 2097152
debug3: receive packet: type 99
debug2: channel_input_status_confirm: type 99 id 0
debug2: shell request accepted on channel 0
Last login: Mon Apr 29 20:55:35 2019 from 192.168.50.127&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;

&lt;p&gt;具体流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;交换密钥完成，发送SSH2_MSG_NEWKEYS表明以后的数据使用对称加密通信（服务端使用相同packet响应）。&lt;/li&gt;
  &lt;li&gt;客户端根据&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-i&lt;/code&gt;选项找到明确指定的将要尝试认证的公钥文件。&lt;/li&gt;
  &lt;li&gt;SSH_MSG_SERVICE_REQUEST请求服务端开启认证协议。&lt;/li&gt;
  &lt;li&gt;同时服务端根据客户端在密钥交换算法中的’ext-info-c’请求，使用SSH_MSG_EXT_INFO公示自身的公钥算法扩展，告知客户端自己支持&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rsa-sha2-256,rsa-sha2-512&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;服务端接受请求，SSH_MSG_SERVICE_ACCEPT。&lt;/li&gt;
  &lt;li&gt;客户端发送SSH_MSG_USERAUTH_REQUEST，并选择method为publickey（又或许是空的）。&lt;/li&gt;
  &lt;li&gt;服务端发送SSH_MSG_USERAUTH_FAILURE，并标明其接受的认证方法只有publickey。&lt;/li&gt;
  &lt;li&gt;客户端直接启用publickey模式，并寻找privatekey。&lt;/li&gt;
  &lt;li&gt;对于第一个发现的（被指定的）privatekey，请求输入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;passphrase&lt;/code&gt;解密私钥，客户端直接签名并发送请求。（而没有尝试询问服务器，这个publickey是否是被授权的（另：openssh client没有，而Bitvise SSH client有））&lt;/li&gt;
  &lt;li&gt;服务端返回&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH_MSG_USERAUTH_SUCCESS&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;密码认证&quot;&gt;密码认证&lt;/h3&gt;

&lt;p&gt;如果使用密码认证，客户端需要发送如下的packet:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_USERAUTH_REQUEST
      string    user name
      string    service name
      string    &quot;password&quot;
      boolean   FALSE
      string    plaintext password in ISO-10646 UTF-8 encoding [RFC3629]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里规定&lt;strong&gt;协议传输&lt;/strong&gt;的密码串必须是以&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ISO-10646 UTF-8&lt;/code&gt;格式编码的，这意味着客户端和服务端在接受输入和最后对比系统（编码）密码的时候都或需要做相应的转换。同时如果协商出的加密算法是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;none&lt;/code&gt;则，不允许使用密码认证，密码修改也不应该被允许。&lt;/p&gt;

&lt;p&gt;对于密码国际化的问题，SSH希望用户输入密码的时候，不考虑当前系统和软件是什么，认证工作依旧能顺利进行。所以需要先对能支持非ASCII密码的系统中的密码和用户名进行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;规范化&lt;/code&gt;当他们要添加数据库或对比的时候，SSH的实现应该使用[RFC4013]对双方存储和对比的密码进行规范化。&lt;/p&gt;

&lt;p&gt;最后如果密码过期，服务端应该发送如下packet：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_USERAUTH_PASSWD_CHANGEREQ
      string    prompt in ISO-10646 UTF-8 encoding [RFC3629]
      string    language tag [RFC3066]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;客户端则需要回复如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_USERAUTH_REQUEST
      string    user name
      string    service name
      string    &quot;password&quot;
      boolean   TRUE
      string    plaintext old password in ISO-10646 UTF-8 encoding
                 [RFC3629]
      string    plaintext new password in ISO-10646 UTF-8 encoding
                 [RFC3629]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;最后的服务器会有如下回复：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;SSH_MSG_USERAUTH_SUCCESS 
  密码已经被改变，已经认证成功&lt;/li&gt;
  &lt;li&gt;SSH_MSG_USERAUTH_FAILURE with partial success
  密码已经被改变，但是需要再认证一次&lt;/li&gt;
  &lt;li&gt;SSH_MSG_USERAUTH_FAILURE without partial success
  密码没有被改变，要么是修改密码功能不被支持，要么是旧的密码是错误的。注意，如果服务器已经发送了SSH_MSG_USERAUTH_PASSWD_CHANGEREQ，就说明他是支持修改密码的。&lt;/li&gt;
  &lt;li&gt;SSH_MSG_USERAUTH_CHANGEREQ
  修改的密码不被接受，可能是修改的密码太简单或者其他。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;host-based认证&quot;&gt;Host-Based认证&lt;/h3&gt;

&lt;p&gt;一些希望站点在自己主机上登陆远程主机用户的认证方式。这样不符合高的安全等级，但他确实很方便。这是一个可选的认证方式，在实现的时候一定要注意防止一个普通的用户有能力窃取到服务器的private host key。&lt;/p&gt;

&lt;p&gt;如果这这种认证方式被启用，客户端只需要提供包括&lt;strong&gt;远程host名称&lt;/strong&gt;、&lt;strong&gt;远程host公钥&lt;/strong&gt;、&lt;strong&gt;远程host私钥签名&lt;/strong&gt;等数据在内的packet：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_USERAUTH_REQUEST
      string    user name
      string    service name
      string    &quot;hostbased&quot;
      string    public key algorithm for host key
      string    public host key and certificates for client host
      string    client host name expressed as the FQDN in US-ASCII
      string    user name on the client host in ISO-10646 UTF-8 encoding
                 [RFC3629]
      string    signature
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;被签名的内容为：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      string    session identifier
      byte      SSH_MSG_USERAUTH_REQUEST
      string    user name
      string    service name
      string    &quot;hostbased&quot;
      string    public key algorithm for host key
      string    public host key and certificates for client host
      string    client host name expressed as the FQDN in US-ASCII
      string    user name on the client host in ISO-10646 UTF-8 encoding
                 [RFC3629]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;服务器甚至可以忽略具体的user name，它必须要做的只有检查host key是否是真的，已经签名是否是有效的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;比较奇怪的是，协议中没有明确的规定如何返回这类认证被拒绝具体packet的解释&lt;/strong&gt;,比如当远程host签名无效，又或者服务器不支持远程host的公钥算法等。&lt;/p&gt;

&lt;h3 id=&quot;keyboard-interactive认证&quot;&gt;keyboard-interactive认证&lt;/h3&gt;

&lt;p&gt;前面的各种认证方法都十分依赖于双端的实现，如果新版本的服务器由启用了一个新的认证方法，那就意味着客户端也必须更新添加方法。又因为“认证”这件事的特殊性（本质上它的计算工作是完全在服务端完成的），人们发现可以设计一种&lt;strong&gt;通用&lt;/strong&gt;的认证方法，像HTTP协议传送的HTML一样（服务端传给客户端的东西客户端并不需要知道他具体是什么，只需要把它显示出来，剩下的交给用户去识别和输入），这种方法的设计目的就是&lt;strong&gt;尽可能的让客户端对于认证过程完全不知情，并且一切都基于用户使用键盘进行的数据交互&lt;/strong&gt;。使用这种方法，服务端可以轻松的扩展具体的认证算法，而客户端可以不需要做任何的更新。&lt;/p&gt;

&lt;p&gt;使用这种认证方法，可以轻松的实现&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;挑战应答式认证&lt;/code&gt;（客户端返回Hash（随机数（挑战）+密码））和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OTP&lt;/code&gt;（每次一密码，如短信登陆）。但是，它在客户端依然是有缺陷的，如果要使用它在认证机制中则不允许有特殊编码，比如硬件驱动或者是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;password mangling&lt;/code&gt;（把简单密码变成复杂密码的工具）。&lt;/p&gt;

&lt;p&gt;主要的消息有3个，SSH_MSG_USERAUTH_REQUEST、SSH_MSG_USERAUTH_INFO_REQUEST、SSM_MSG_USERAUTH_INFO_RESPONSE。&lt;/p&gt;

&lt;p&gt;SSH_MSG_USERAUTH_REQUEST由客户端发送给服务端，用于启用这一认证方法，语言标签是不推荐使用的。同时如果客户端足够确信可以把&lt;strong&gt;用户&lt;/strong&gt;期望使用的方法填在submethods里，逗号分隔。之后服务端&lt;strong&gt;可以&lt;/strong&gt;根据自己的实现选择是否参照submethods，提示用户选择具体的认证方法。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_USERAUTH_REQUEST
      string    user name (ISO-10646 UTF-8, as defined in [RFC-3629])
      string    service name (US-ASCII)
      string    &quot;keyboard-interactive&quot; (US-ASCII)
      string    language tag (as defined in [RFC-3066])
      string    submethods (ISO-10646 UTF-8)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;服务端收到上述方法后必须回复SSH_MSG_USERAUTH_SUCCESS、SSH_MSG_USERAUTH_FAILURE、SSH_MSG_USERAUTH_INFO_REQUEST消息其中的一个。并且协议规定如果用户填写了错误的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;service name&lt;/code&gt;或者&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user name&lt;/code&gt;服务器并不能直接发送SSH_MSG_USERAUTH_FAILURE。相反的，它应该再一次发送SSH_MSG_USERAUTH_INFO_REQUEST，然后忽略客户端对于这个request的回应（不论他是否是完全认证正确的），再在一个&lt;strong&gt;可配置的时间（默认是2秒）&lt;/strong&gt;后发送SSH_MSG_USERAUTH_FAILURE，这么做的目的是阻止用户通过对比结果猜测出合法的用户名。&lt;/p&gt;

&lt;p&gt;之后服务端则根据自己的实现选择一个认证方式询问客户端。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_USERAUTH_INFO_REQUEST
      string    name (ISO-10646 UTF-8)
      string    instruction (ISO-10646 UTF-8)
      string    language tag (as defined in [RFC-3066])
      int       num-prompts
      string    prompt[1] (ISO-10646 UTF-8)
      boolean   echo[1]
      ...
      string    prompt[num-prompts] (ISO-10646 UTF-8)
      boolean   echo[num-prompts]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;name为请求信息的名称，instruction为具体的详细指示用户填写的内容，每个prompts为每次STDIN打开前输出的提示。协议考虑到不同的终端设备在显示上的能力或许会有局限，这个输出局限或许会对认证的结果造成影响。所以，应该至少保证&lt;strong&gt;instruction&lt;/strong&gt;完全被显示，&lt;strong&gt;name和prompt至少30个字符显示，且如果被截取必须明确地让用户知道发生了截取&lt;/strong&gt;。哪怕，num-prompt为0时，instruction和name一样需要被正常显示（比如，通知最后认证成功的时候，就不再需要用户输入了）。&lt;/p&gt;

&lt;p&gt;如下是用户做出的应答的消息格式,num-responses必须和num-prompts长度一致。密码输入、传输的部分和上文一样，一样需要被规范化。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_USERAUTH_INFO_RESPONSE
      int       num-responses
      string    response[1] (ISO-10646 UTF-8)
      ...
      string    response[num-responses] (ISO-10646 UTF-8)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;最后，协议规定如果认证发生错误（密码错误之类），不应该发送SSH_MSG_USERAUTH_INFO_REQUEST让用户重新输入，除非是这个认证是（类似于或运算）的补充形式。因为，还有其他的认证方法需要被尝试。下文是RFC描述的一个可以被运用的样例：&lt;/p&gt;
&lt;details&gt;
  &lt;summary&gt;详情&lt;/summary&gt;
  &lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;C:   byte      SSH_MSG_USERAUTH_REQUEST
C:   string    &quot;user23&quot;
C:   string    &quot;ssh-userauth&quot;
C:   string    &quot;keyboard-interactive&quot;
C:   string    &quot;en-US&quot;
C:   string    &quot;
S:   byte      SSH_MSG_USERAUTH_INFO_REQUEST
S:   string    &quot;Password Authentication&quot;
S:   string    &quot;&quot;
S:   string    &quot;en-US&quot;
S:   int       1
S:   string    &quot;Password: &quot;
S:   boolean   FALS
[Client prompts user for password
C:   byte      SSH_MSG_USERAUTH_INFO_RESPONSE
C:   int       1
C:   string    &quot;password
S:   byte      SSH_MSG_USERAUTH_INFO_REQUEST
S:   string    &quot;Password Expired&quot;
S:   string    &quot;Your password has expired.&quot;
S:   string    &quot;en-US&quot;
S:   int       2
S:   string    &quot;Enter new password: &quot;
S:   boolean   FALSE
S:   string    &quot;Enter it again: &quot;
S:   boolean   FALS
[Client prompts user for new password
C:   byte      SSH_MSG_USERAUTH_INFO_RESPONSE
C:   int       2
C:   string    &quot;newpass&quot;
C:   string    &quot;newpass&quot;

S:   byte      SSH_MSG_USERAUTH_INFO_REQUEST
S:   string    &quot;Password changed&quot;
S:   string    &quot;Password successfully changed for user23.&quot;
S:   string    &quot;en-US&quot;
S:   int       0
[Client displays message to user]

C:   byte      SSH_MSG_USERAUTH_INFO_RESPONSE
C:   int       0

S:   byte      SSH_MSG_USERAUTH_SUCCESS&lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;花了三四天的时间整理这篇文章，有了一些体会与理解：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在密码学的相关程序实现中，密钥对是1-1对应的。&lt;/li&gt;
  &lt;li&gt;非对称加解密的速度不及对称加解密，所以在SSH中的private/public key主要是用来认证的。
    &lt;ol&gt;
      &lt;li&gt;private key加密的数据叫做签名。（签名 + public key）is a proof of possession of a private key。&lt;/li&gt;
      &lt;li&gt;public key可以从private key文件中导出(所以客户端一个private文件就可以认证)。
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh-keygen -y -f ~/.ssh/id_rsa&lt;/code&gt; openssh标准
            &lt;ul&gt;
              &lt;li&gt;The key type&lt;/li&gt;
              &lt;li&gt;A chunk of PEM-encoded data&lt;/li&gt;
              &lt;li&gt;A comment&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh-keygen -e -f ~/.ssh/id_rsa&lt;/code&gt; ssh标准&lt;a href=&quot;https://tools.ietf.org/html/rfc4716#section-3.3&quot;&gt;rfc4716&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;最原始的安全保障是由Key Exchange Algrorithm提供的。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;椭圆曲线密钥交换算法的绝大多数参数都是预设的，不像DH需要临时协商。&lt;/li&gt;
  &lt;li&gt;如果需要制定一套协议或是标准，例如rfc，数据类型的&lt;strong&gt;编码&lt;/strong&gt;是必须要被考虑在内的；同时应该尽量的将协议设计成&lt;strong&gt;不依赖于次序&lt;/strong&gt;的。&lt;/li&gt;
  &lt;li&gt;ssh的verbose选项提供最多3个v，来输出不同层级的debug信息。&lt;/li&gt;
  &lt;li&gt;因为私钥不需要传递所以rfc4176只表明其是公钥格式，但其实它也是私钥文件的格式，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh-keygen&lt;/code&gt;中有说明，默认keygen出来的私钥就是符合rfc4176格式的。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh -i&lt;/code&gt;选项可以手动临时添加私钥，并且它将最先被尝试。之后将一次尝试 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh-add -L&lt;/code&gt;中的私钥，最后尝试&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.ssh/id_rsa&lt;/code&gt;等。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.openssh.com/specs.html&quot;&gt;OpenSSH Specifications&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;这是OpenSSH所展现的最直接的资料页面，但是有很多细节部分的规格与实现没有罗列。而且RFC文档错综复杂，有很多地方都引用不全必须靠“幸运”才能翻看到。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.mnin.org/write/2006_sshcrypto.html&quot;&gt;Cryptography of SSH&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;在这个页面可以很直观的看到到DH密钥交换协议的流程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4251&quot;&gt;The Secure Shell (SSH) Protocol Architecture&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;SSH协议架构的rfc页面，它将SSH分为三部分，传输、认证和连接。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4253#section-7&quot;&gt;The Secure Shell (SSH) Transport Layer Protocol&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;SSH传输层协议的rfc页面，在这里主要讨论如何为协议提供加密、服务端认证、数据完整性保护、压缩协议内容等功能。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5656#page-5&quot;&gt;Elliptic Curve Algorithm Integration in the Secure Shell Transport Layer&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;这篇rfc将ECDH算法集成在SSH传输层协议中，用作签名和密钥交换。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://git.libssh.org/projects/libssh.git/tree/doc/curve25519-sha256@libssh.org.txt&quot;&gt;curve25519-sha256@libssh.org.txt&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;这篇文章描述了curve25519密钥交换算法，它提供了一个可以替代的方法给DH算法或ECDH算法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-curdle-ssh-kex-sha2-03&quot;&gt;Key Exchange (KEX) Method Updates and Recommendations for Secure Shell (SSH)&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;2016年更新的SSH密钥交换算法更新建议。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-curdle-ssh-curves-00#ref-Curve25519&quot;&gt;  Secure Shell (SSH) Key Exchange Method using Curve25519 and Curve448 draft-ietf-curdle-ssh-curves-00&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;这篇文章描述了在SSH中如何实现Curve25519。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://cr.yp.to/ecdh/curve25519-20060209.pdf&quot;&gt;Curve25519: New Diffie-Hellman Speed Records&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;25519曲线原论文。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7748&quot;&gt;Elliptic Curves for Security&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;具体介绍Curve25519在密码学中的应用，相关函数使用说明。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4255#page-2&quot;&gt;Using DNS to Securely Publish Secure Shell (SSH) Key Fingerprints&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;介绍SSH fingerprint以及推荐的使用方式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8308#page-6&quot;&gt;Extension Negotiation in the Secure Shell (SSH) Protocol&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;介绍SSH中如何查询扩展信息，并使用共有的（认证）相关扩展。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc8332&quot;&gt;Use of RSA Keys with SHA-256 and SHA-512 in the Secure Shell (SSH) Protocol&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;标准规定扩展使用RSA配合SHA摘要算法完成认证操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4250&quot;&gt;The Secure Shell (SSH) Protocol Assigned Numbers&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;规定协议中各种ID（宏）所使用的序号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4716#section-3.3&quot;&gt;The Secure Shell (SSH) Public Key File Format&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;SSH定义的公钥文件格式标准。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4256&quot;&gt;Generic Message Exchange Authentication for the Secure Shell Protocol (SSH)&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;这个标准定义了一种基于键盘交互的通用认证方法。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-04-28T00:00:00+08:00&quot;&gt;
                2019-04-28
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Sun, 28 Apr 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/04/28/SSH/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/28/SSH/</guid>
        
        <category>密码学</category>
        
        <category>rfc</category>
        
        <category>网络协议</category>
        
        
        <category>SSH</category>
        
      </item>
    
      <item>
        <title>Mac使用SSH连接虚拟机内Linux缓慢</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#问题背景&quot; id=&quot;markdown-toc-问题背景&quot;&gt;问题背景&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#问题表现&quot; id=&quot;markdown-toc-问题表现&quot;&gt;问题表现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#解决方案&quot; id=&quot;markdown-toc-解决方案&quot;&gt;解决方案&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#reference&quot; id=&quot;markdown-toc-reference&quot;&gt;Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;问题背景&quot;&gt;问题背景&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Mac作为客户机连接位于同局域网下Windows内部的CentOS虚拟机。&lt;/li&gt;
  &lt;li&gt;Mac设置了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;主机名&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;问题表现&quot;&gt;问题表现&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;SSH连接十分缓慢，不论使用任何软件。&lt;/li&gt;
  &lt;li&gt;SSH缓慢分为两个阶段：
    &lt;ol&gt;
      &lt;li&gt;确认密码之前使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-v&lt;/code&gt;输出详细信息，Mac端将会停留在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSH2_MSG_SERVICE_ACCEPT received&lt;/code&gt;10秒左右。&lt;/li&gt;
      &lt;li&gt;输入密码后，没有更多输出，并停留一分钟左右。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;进入Server端:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo vim /etc/ssh/sshd_config&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;` UseDNS no`。&lt;/li&gt;
  &lt;li&gt;重启sshd。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strace&lt;/code&gt;命令可以用来追踪某个进程正在进行的系统调用。&lt;/li&gt;
&lt;/ol&gt;

 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-04-21T00:00:00+08:00&quot;&gt;
                2019-04-21
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Sun, 21 Apr 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/04/21/SSH_LAG/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/21/SSH_LAG/</guid>
        
        <category>SSH</category>
        
        <category>Mac</category>
        
        <category>Linux</category>
        
        
        <category>解决问题</category>
        
      </item>
    
      <item>
        <title>VMware下Linux无法播放声音的解决方案</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#问题背景&quot; id=&quot;markdown-toc-问题背景&quot;&gt;问题背景&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#解决方案&quot; id=&quot;markdown-toc-解决方案&quot;&gt;解决方案&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#reference&quot; id=&quot;markdown-toc-reference&quot;&gt;Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;问题背景&quot;&gt;问题背景&lt;/h2&gt;

&lt;p&gt;宿主机环境： Windows 10&lt;/p&gt;

&lt;p&gt;VMware Workstation版本：VMware Workstation 12 、VMware Workstation 15&lt;/p&gt;

&lt;p&gt;客户机环境： CentOS 7、 Ubuntu（版本未知）&lt;/p&gt;

&lt;p&gt;具体问题表现情况：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.如果客户机是Windows10，一切声音表现正常。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2.如果是上述客户及环境，则无法播放声音，在Linux系统中可以查看到相关声卡以及可以拖动相关音量条，但是就是没有声音播放。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3.开机时右下角显示&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A device ID has been used that is out of range for your system . . .&lt;/code&gt;(已使用超出系统范围的设备ID …)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;确保虚拟机是正在运行的 -&amp;gt; 直接在VMware Workstation(宿主机中) -&amp;gt; 虚拟机 -&amp;gt; 可移动设备 -&amp;gt; 声卡 -&amp;gt; 连接。&lt;/p&gt;

    &lt;p&gt;这样当前的Linux就能播放声音了，但是缺点是它并不能在虚拟机开启的时候自动连接，哪怕勾选了相关选项。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重复上述步骤。&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;在宿主机（Windows 10）右下角喇叭处右键 -&amp;gt; 声音。&lt;/li&gt;
      &lt;li&gt;录制选项卡。&lt;/li&gt;
      &lt;li&gt;打开&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;立体声混音&lt;/code&gt;。&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;这样就可以虚拟机开机时自动连接了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://kb.vmware.com/s/article/2086551&quot;&gt;VMware知识库&lt;/a&gt;:但是这篇文章中说，设置默认主机声卡不需要打开立体声混音也能正常运作，可是在我的环境中不论如何都必须打开立体声混音。&lt;/li&gt;
&lt;/ol&gt;

 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-04-20T00:00:00+08:00&quot;&gt;
                2019-04-20
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Sat, 20 Apr 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/04/20/VMwareSoundIssue/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/20/VMwareSoundIssue/</guid>
        
        <category>VMware</category>
        
        
        <category>解决问题</category>
        
      </item>
    
      <item>
        <title>数据结构（三）：静态线性单链表的C++实现</title>
        
        
        <description> 
&lt;p&gt;本文使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;实现了严蔚敏老师«数据结构»中的抽象数据类型&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;静态线性单链表&lt;/code&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;script src=&quot;https://gist.github.com/eMous/dfe67c1499512f9efc45350ea4ff797d.js&quot;&gt;&lt;/script&gt;

 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-04-15T00:00:00+08:00&quot;&gt;
                2019-04-15
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Mon, 15 Apr 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/04/15/DataStructure_StaticLinkList_C++/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/15/DataStructure_StaticLinkList_C++/</guid>
        
        <category>C++</category>
        
        
        <category>数据结构</category>
        
      </item>
    
      <item>
        <title>数据结构（二）：线性单链表的C++实现</title>
        
        
        <description> 
&lt;p&gt;本文使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;实现了严蔚敏老师«数据结构»中的抽象数据类型&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;线性单链表&lt;/code&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;script src=&quot;https://gist.github.com/eMous/97f3617d6c29fdd677acfb9e7610aec6.js&quot;&gt;&lt;/script&gt;

 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-04-15T00:00:00+08:00&quot;&gt;
                2019-04-15
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Mon, 15 Apr 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/04/15/DataStructure_LinkList_C++/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/15/DataStructure_LinkList_C++/</guid>
        
        <category>C++</category>
        
        
        <category>数据结构</category>
        
      </item>
    
      <item>
        <title>数据结构（一）：顺序表的C++实现</title>
        
        
        <description> 
&lt;p&gt;本文使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;实现了严蔚敏老师«数据结构»中的抽象数据类型&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;顺序线性表&lt;/code&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;script src=&quot;https://gist.github.com/eMous/c53c2e3c8adb544c38f7c2333c60dcf6.js&quot;&gt;&lt;/script&gt;

 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-04-10T00:00:00+08:00&quot;&gt;
                2019-04-10
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Wed, 10 Apr 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/04/10/DataStructure_SeqList_C++/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/10/DataStructure_SeqList_C++/</guid>
        
        <category>C++</category>
        
        
        <category>数据结构</category>
        
      </item>
    
      <item>
        <title>使用Webstorm编写Jekyll</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#webstorm&quot; id=&quot;markdown-toc-webstorm&quot;&gt;Webstorm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#优点&quot; id=&quot;markdown-toc-优点&quot;&gt;优点&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#配置&quot; id=&quot;markdown-toc-配置&quot;&gt;配置&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#页面调试&quot; id=&quot;markdown-toc-页面调试&quot;&gt;页面调试&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#专属调试技巧&quot; id=&quot;markdown-toc-专属调试技巧&quot;&gt;专属调试技巧&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#注意事项&quot; id=&quot;markdown-toc-注意事项&quot;&gt;注意事项&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/06/Snipaste_2019-04-06_21-52-54.png&quot; /&gt;&lt;/div&gt;

&lt;h2 id=&quot;webstorm&quot;&gt;Webstorm&lt;/h2&gt;

&lt;p&gt;说到Webstorm，你会想到什么，是那个你分不清到底对应着哪个旗下软件的矢量Logo吗？如果我是你，我会很难回答这个问题。因为，我会想到PhpStorm，Pycharm，Clion甚至Android
Studio，可是这并不是这个问题我想给出的答案，因为我始终都没办法自然而然地想到&lt;strong&gt;JetBrains&lt;/strong&gt;这个名字。可能是实在太难记，又或许是因为陷入了产品的光芒掩盖了品牌而产品间又几乎全是共性的矛盾之中。&lt;/p&gt;

&lt;p&gt;对我而言，因为之前大多都是开发&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;php-cli&lt;/code&gt;的缘故，再加上之后做过一段时间&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Yii&lt;/code&gt;的前后端工作，所以用Phpstorm应该是所有IDE里最多的。相比之下，Webstorm也是当前才接触没有多长时间，虽然让我感觉它各种方面&lt;abbr title=&quot;混乱的文件与（模板、补全）等功能的关联，插件功能和可编辑功能无法得到一致的表现。&quot;&gt;欠缺&lt;/abbr&gt;一点。但这并不能影响多少，相比之下JetBrains旗下的那股专注和克制仍然是让人无法拒绝的王牌。&lt;/p&gt;

&lt;p&gt;如果把如今的Visual Studio比作大型车床，满窗口都是功能按钮各种语言一应俱全，但是庞大且繁杂，假死崩溃无法彻底删除是常有的事情；而VS
code，鉴于他有优秀的extension生态，姑且把它当作车床模型；最后JetBrains旗下的各IDE就是车床产出的各类刀具，它们比不上车床通用，但是对于自己方向上的问题恰好胜任而且绝不拖沓。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;优点&quot;&gt;优点&lt;/h2&gt;

&lt;p&gt;面对Jekyll的相关任务，Webstorm相比于VS code有几个明显的优点。&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;&lt;del&gt;&lt;strong&gt;更全面的版本控制支持&lt;/strong&gt;&lt;/del&gt;&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;&lt;del&gt;虽然它还是没有SourceTree那么优秀，比如没有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Git Flow&lt;/code&gt;。但是
你可以在右下角，轻松的切换分支和IDE内的快捷键Commit和Push，单单这两点我就很心满意足了。&lt;/del&gt;&lt;/p&gt;
  &lt;/dd&gt;
  &lt;dt&gt;&lt;strong&gt;更安全的关联文件变动提醒&lt;/strong&gt;&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;Webstorm能人性化地探测并尽可能全地管理项目中地文件，哪怕是在文件中使用字符串关联的文件，在它被移除或更名之前，Webstorm都会把所有的关联文件列出让你确认。&lt;/p&gt;
  &lt;/dd&gt;
  &lt;dt&gt;&lt;strong&gt;轻松配置、切换调试器&lt;/strong&gt;&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;毕竟VScode是编辑器出生，编译调试之类的功能不是自己的看家本领。然而Webstorm的定位本身就是Web开发IDE，这也就自然而然了，无需手动编写文件一切都是GUI实现。&lt;/p&gt;
  &lt;/dd&gt;
  &lt;dt&gt;&lt;strong&gt;比VS Code Snippet功能更全的Live template&lt;/strong&gt;&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;VS Code的Snippet是和文件类型强耦合的，意味着每个文件只能跑自己类型的Snippet。然而，Live template则完全不同，虽说Webstorm自己的File Types也是乱七八糟，自定义的File Types不如狗，只能沦为Live template的Others类。但是，在基本的功能上Live template是比Snippet强大且灵活的，&lt;strong&gt;Webstorm提供Live template暴露给哪些语言（文件）类型的设置。&lt;/strong&gt; 这意味着，js文件可以使用twig&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;类型的Live template，提供建议补全基本&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Liquid&lt;/code&gt;语句。&lt;/p&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/06/Snipaste_2019-04-06_23-02-56.png&quot; /&gt;&lt;/div&gt;

&lt;dl&gt;
  &lt;dt&gt;&lt;strong&gt;Markdown Navigation Plugin配合Language Injection&lt;/strong&gt;&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;Markdown Navigation是Webstorm下的Markdown增强插件，它能提供基本的Markdown功能。但是，他的Preview功能做的并不好，因为他无法识别基于项目绝对路径的图片，而且自动换行功能有时候也很烦人（这个可以通过开启soft wrap解决），这些都可以通过同屏左右两侧浏览器预览-写作实现。但是他配合Webstorm的Language Injection可以让Html,CSS,Javascript代码在md文件下编写变得无懈可击(比如使用img标签的时候，在其内部可以自动代码建议)。&lt;/p&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;

&lt;dl&gt;
  &lt;dt&gt;&lt;strong&gt;给newpost配置Live Template&lt;/strong&gt;&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;加在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Markdown&lt;/code&gt;组中，暴露给markdown文件使用，名为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.newpost&lt;/code&gt;:其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$fileName$&lt;/code&gt;为已定义变量，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$date$&lt;/code&gt;为日期函数值。&lt;/p&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nn&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;$fileName$&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Anon&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;layout&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;post&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;$title$&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;$date$&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;categories&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;$categories$&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;tags&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;$tags$&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;$description$&lt;/span&gt;
&lt;span class=&quot;nn&quot;&gt;---&lt;/span&gt;


&lt;span class=&quot;err&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;content&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;{:&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;toc&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;}&lt;/span&gt;



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;dl&gt;
  &lt;dt&gt;&lt;strong&gt;给img配置Live Template&lt;/strong&gt;&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;加在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Markdown&lt;/code&gt;组中，暴露给markdown文件使用，名为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.img&lt;/code&gt;,相比于普通的Markdown Image多了居中功能。&lt;/p&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;&amp;lt;div style=&quot;text-align&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;center;&quot;&amp;gt;&amp;lt;img style=&quot;height:$height$;width:$width$;&quot; alt=&quot;$alt$&quot; title=&quot;$title$&quot; src=&quot;$src$&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;dl&gt;
  &lt;dt&gt;&lt;strong&gt;开放Twig Live Template给js和css&lt;/strong&gt;&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;当编辑主题或是调试功能代码的时候，需要在Javascript或CSS文件中用到Liquid，这时候这个功能就会很有用。&lt;/p&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/06/Snipaste_2019-04-07_01-06-13.png&quot; /&gt;&lt;/div&gt;

&lt;h2 id=&quot;页面调试&quot;&gt;页面调试&lt;/h2&gt;

&lt;p&gt;同样的，在页面调试方面Webstorm也有很强劲的表现。配合名为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JetBrain IDE Support Options&lt;/code&gt;的Chrome插件，可以实现在未给Chrome配置Source Map的情况下完成热刷新。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/06/Snipaste_2019-04-07_01-24-37.png&quot; /&gt;&lt;/div&gt;

&lt;h3 id=&quot;专属调试技巧&quot;&gt;专属调试技巧&lt;/h3&gt;

&lt;p&gt;在Webstorm中你甚至可以直接在项目目录的Javascript文件中打断点，他一样会Debugger住，然后让你修改，（我估计这只是单纯检查文件名造成的Bug），哪怕这是一个满是Liquid的文件（如果是这种情况它会断到最后一行）。&lt;/p&gt;

&lt;h2 id=&quot;注意事项&quot;&gt;注意事项&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果你下载了Twig插件，你可能会发现在.Twig的文本中竟然没有任何补全信息。而且你在设置中找不到任何相关的信息，然而其他的所有文件（其实也并不是）都有补全，除了纯Text文件。这个时候，你或许要怀疑它的插件有Bug从而让系统误认为是Text文件了，其实这并不是这样的，因为他是静态模板文件，这就意味着文件中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;标签&lt;/code&gt;外区域是大量的纯文本输出内容，因此不适宜提供代码提示，你可以手动唤醒他们&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctrl + J&lt;/code&gt;或者&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctrl + Space&lt;/code&gt;。至于为什么可以通过插件做这种拒绝弹出提示的操作，而在设置中无法做到，就不得而知了，所以我觉得Webstorm其实也挺混乱的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Chrome自带的HMR只支持Javascript和CSS两种，就是说在Webstorm里修改Javascript或者scss模板都能直接在Chrome里响应（如果基于Chrome的HMR，虽然它也可能随时需要再激活一次，但是它确实更精确也更可靠，除了不能热更新Html文件意外）。但是如果要连同Html一起更新则需要Live Edit（对于CSS的刷新有一些文件有用而一些则没响应，所以需要配合Chrome的HMR一起使用，特别是debug选项没有配置的文件。），但是Webstorm自带的Synchronization功能又有一定的问题，如果修改模板文件，它并不能自动的检测到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_site&lt;/code&gt;文件夹的变动并同步给Chrome里的插件。这个时候可以使用手动快捷键&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctrl+Alt+Y&lt;/code&gt;或者将鼠标单击到别的应用程序窗口再回到Webstorm再或者将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_site&lt;/code&gt;下的文件一起打开在Editor的一个Tab中。
  &lt;strong&gt;所以最后得出的结论就是：写post就用Webstorm一边写，一边单击切换Chrome可以实时预览；修改样式就直接用Chrome的Workspace可以实时预览；修改Javascript则用Webstorm可以直接在模板文件处打断点。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;很奇怪的，不知道是什么原因，在Webstorm中的文件其实是自动保存的。因为哪怕不点击&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctrl+S(Save ALL)&lt;/code&gt;一样是可以在VS Code里看到文件的变动的，但是不点击&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Save ALL&lt;/code&gt;jekyll的watcher就无法检测到文件的变动。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Webstorm插件,有基本的Liquid语法高亮。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-04-06T00:00:00+08:00&quot;&gt;
                2019-04-06
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Sat, 06 Apr 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/04/06/UseWebstormToWriteJekyll/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/06/UseWebstormToWriteJekyll/</guid>
        
        <category>Webstorm</category>
        
        <category>Jekyll</category>
        
        
        <category>生产环境</category>
        
      </item>
    
      <item>
        <title>使用VSCode编写Jekyll</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#一开始我是如何做的&quot; id=&quot;markdown-toc-一开始我是如何做的&quot;&gt;一开始我是如何做的？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#开始使用vs-code&quot; id=&quot;markdown-toc-开始使用vs-code&quot;&gt;开始使用VS Code&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#不再需要powershell&quot; id=&quot;markdown-toc-不再需要powershell&quot;&gt;不再需要Powershell&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#版本控制符号&quot; id=&quot;markdown-toc-版本控制符号&quot;&gt;版本控制符号&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#项目内快速文件名搜索&quot; id=&quot;markdown-toc-项目内快速文件名搜索&quot;&gt;项目内快速文件名搜索&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#直接预览markdown&quot; id=&quot;markdown-toc-直接预览markdown&quot;&gt;直接预览Markdown&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#开发与调试&quot; id=&quot;markdown-toc-开发与调试&quot;&gt;开发与调试&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#配置工作区&quot; id=&quot;markdown-toc-配置工作区&quot;&gt;配置工作区&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#开启jekyll&quot; id=&quot;markdown-toc-开启jekyll&quot;&gt;开启Jekyll&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#配置debug&quot; id=&quot;markdown-toc-配置debug&quot;&gt;配置Debug&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#开始调试&quot; id=&quot;markdown-toc-开始调试&quot;&gt;开始调试&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:400px;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/05/make-up-brushes.svg&quot; /&gt;&lt;/div&gt;

&lt;p&gt;到今天，我才终于能体会到为什么&lt;a href=&quot;https://fishc.com.cn/&quot;&gt;小甲鱼&lt;/a&gt;总会在他的教程里告诫所有初学者使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Notepad%2B%2B&quot;&gt;Notepad++&lt;/a&gt;进行编程。因为面对一个未知的事物，&lt;strong&gt;如果你的第一反应就是寻找捷径，那这意味着你将缺失一大部分由试错构建起的对其的宏观的认知。&lt;/strong&gt; 当你有足够多的尝试，已把它的基本操作弄得明白后，才能对其构建起一个相对清晰的框架，对于之后发生问题可以才能有一个准确的描述。&lt;/p&gt;

&lt;p&gt;这个试错的过程长短是因人而异的，至少对我来说，当我有意无意地察觉到我的问题解决过程存在模式之后。我便自然而然地想到工具，自动化方法，集成开发环境……&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一开始我是如何做的&quot;&gt;一开始我是如何做的？&lt;/h2&gt;

&lt;p&gt;最开始的时候，我使用的是&lt;a href=&quot;https://en.wikipedia.org/wiki/Sublime_Text&quot;&gt;Sublime Text&lt;/a&gt;编辑博客样式与博客内容，配合&lt;a href=&quot;https://en.wikipedia.org/wiki/PowerShell&quot;&gt;Powershell&lt;/a&gt;对Jekyll进行启停，通过Chrome浏览本地端地样式，最后使用&lt;a href=&quot;https://www.sourcetreeapp.com/&quot;&gt;SourceTree&lt;/a&gt;将Jekyll推到Github Page再最后预览一遍。&lt;/p&gt;

&lt;p&gt;像这样:&lt;/p&gt;

&lt;center&gt;&lt;img alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/05/Snipaste_2019-04-05_11-25-40.png&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;img alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/05/Snipaste_2019-04-05_11-27-18.png&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;img alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/05/Snipaste_2019-04-05_11-28-03.png&quot; /&gt;&lt;/center&gt;

&lt;p&gt;现在回想起来确实是挺痛苦的回忆，特别是当时调试Feed的时候，一心想在每个单独的RSS post里增加样式以便他人在浏览时可以无需打开网站就看到相对美观的页面。然而，那些如&lt;a href=&quot;https://feedly.com&quot;&gt;Feedly&lt;/a&gt;之类能显示单独item description的网站又无法提供localhost的feed嗅探服务，所以只能如是依次地修改在推到Github Page再等待Feedly更新，极其痛苦。然而最后实验证明，&lt;strong&gt;RSS里的内容如果有Style绝大多数是不会被解析的。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;开始使用vs-code&quot;&gt;开始使用VS Code&lt;/h2&gt;
&lt;p&gt;因为我没有成为过专职的前端开发人员，所以我对VS Code其实也并不是太熟悉，下面的这些配置都是凭着操作和试错的模式得到的，也就是说&lt;strong&gt;因为频繁的操作和出错，我才想到有没有某些功能或插件，恰巧大多数都有。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;不再需要powershell&quot;&gt;不再需要Powershell&lt;/h4&gt;

&lt;p&gt;使用VS Code将Jekyll目录打开后，编辑框下面的Terminal会自动打开一个Powershell并且进入当前目录。直接运行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jekyll s&lt;/code&gt;，之后除非出现故障都无需理会。&lt;/p&gt;
&lt;center&gt;&lt;img alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/05/Snipaste_2019-04-05_11-43-50.png&quot; /&gt;&lt;/center&gt;

&lt;h4 id=&quot;版本控制符号&quot;&gt;版本控制符号&lt;/h4&gt;

&lt;p&gt;和常用的IDE一样，如果打开的目录内有git仓库，VS Code也会通过git实时的呈现每个文件或文件夹版本变动的标志。&lt;span style=&quot;color:green&quot;&gt;绿色&lt;/span&gt;是未追踪（新建），&lt;span style=&quot;color:orange&quot;&gt;黄色&lt;/span&gt;是修改，&lt;span style=&quot;color:red&quot;&gt;红色&lt;/span&gt;是删除。&lt;/p&gt;
&lt;center&gt;&lt;img alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/05/Snipaste_2019-04-05_11-50-20.png&quot; /&gt;&lt;/center&gt;

&lt;h4 id=&quot;项目内快速文件名搜索&quot;&gt;项目内快速文件名搜索&lt;/h4&gt;

&lt;p&gt;在打开的文件夹或工作区内，直接输入英文字母即可定位并筛选出文件夹。&lt;/p&gt;
&lt;center&gt;&lt;img alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/05/Snipaste_2019-04-05_11-57-13.png&quot; /&gt;&lt;/center&gt;

&lt;h4 id=&quot;直接预览markdown&quot;&gt;直接预览Markdown&lt;/h4&gt;

&lt;p&gt;配合&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Markdown Preview Enhanced&lt;/code&gt;插件，可以直接预览准备post的文件，美中不足的就是需要Jekyll模板编译的layout无法实时的预览。&lt;/p&gt;

&lt;h3 id=&quot;开发与调试&quot;&gt;开发与调试&lt;/h3&gt;

&lt;p&gt;甚至，当我在开发Jekyll-demos的时候都有尝试过使用VS Code作为主力编辑器。&lt;/p&gt;

&lt;h4 id=&quot;配置工作区&quot;&gt;配置工作区&lt;/h4&gt;

&lt;p&gt;网络上关于VS Code工作区的知识很少，在这一步我折腾了不少的时间。&lt;/p&gt;

&lt;p&gt;使用VS Code打开Jekyll文件夹，之后&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;File -&amp;gt; Save workspace as&lt;/code&gt;，将创建一个工作区的配置文件用于记录工作区包含哪些文件夹以及相关的配置。&lt;/p&gt;

&lt;h4 id=&quot;开启jekyll&quot;&gt;开启Jekyll&lt;/h4&gt;

&lt;p&gt;打开工作区，执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jekyll s&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;配置debug&quot;&gt;配置Debug&lt;/h4&gt;

&lt;p&gt;进入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Debug&lt;/code&gt;页面(第四个，&lt;del&gt;蜘蛛&lt;/del&gt;样式)，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Add config(你的工作区)&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Use&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;IntelliSense&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;learn&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;about&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;possible&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;attributes.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Hover&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;descriptions&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;existing&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;attributes.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;For&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;more&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;information&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;visit:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;https://go.microsoft.com/fwlink/?linkid=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;830387&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0.2.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;configurations&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;chrome&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;request&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;launch&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Debug Jekyll&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;url&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:4000/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;webRoot&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;${workspaceFolder}/_site&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;开始调试&quot;&gt;开始调试&lt;/h4&gt;

&lt;p&gt;你可以直接在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_site/&lt;/code&gt;下的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Html&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Javascript&lt;/code&gt;页面中设置断点和设置Watch，他将如期被断下。&lt;/p&gt;
&lt;center&gt;&lt;img alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/05/Snipaste_2019-04-05_12-16-09.png&quot; /&gt;&lt;/center&gt;

&lt;p&gt;配合甚至Chrome的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SourceMap&lt;/code&gt;，你可以在无需刷新页面的情况下修改&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CSS&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;js&lt;/code&gt;。&lt;/p&gt;
&lt;center&gt;&lt;img alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/05/Snipaste_2019-04-05_12-28-38.png&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;img alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/05/Snipaste_2019-04-05_12-28-57.png&quot; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;img alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/05/Snipaste_2019-04-05_12-32-00.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;绿色的部分圆点表示当前页面以及和文档中的文件Map起来，可以实时修改更新。&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;&lt;strong&gt;!但是&lt;/strong&gt;，由于Jekyll先天的缺陷，这个修改过的文件并不是模板文件而是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_site&lt;/code&gt;下的文件。所以都是无效的，我曾因为这个失误五六小时小时的代码全部在一次模板编译后消失不见。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;综上，VS Code提供了很多先进且快捷的特性，尤其是在撰写内容的时候基本只需要一个软件就可以完成所有工作。但是，VSCode的Debug功能Chrome响应实在太慢，最后我还是不得不放弃并转用WebStorm处理开发任务。&lt;/p&gt;
 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-04-05T00:00:00+08:00&quot;&gt;
                2019-04-05
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Fri, 05 Apr 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/04/05/UseVisualStudioCodeToWriteWithJekyll/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/05/UseVisualStudioCodeToWriteWithJekyll/</guid>
        
        <category>VSCode</category>
        
        <category>Jekyll</category>
        
        <category>Chrome</category>
        
        
        <category>生产环境</category>
        
      </item>
    
      <item>
        <title>Jekyll-demos为你展示demo助力</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#起源&quot; id=&quot;markdown-toc-起源&quot;&gt;起源&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#长处&quot; id=&quot;markdown-toc-长处&quot;&gt;长处&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#原理&quot; id=&quot;markdown-toc-原理&quot;&gt;原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img alt=&quot;&quot; title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/eMous/__ResourceRepository/master/Jekyll_demos/2019/04/04/jekyll_demos_v1_intro.gif&quot; /&gt;&lt;/center&gt;

&lt;p&gt;Jekyll-demos 是一套纯粹使用Jekyll完成的用来展示你的前端页面（包括但不限于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;html/js/css&lt;/code&gt;）的解决方案。因为它不是基于Ruby编写，所以它称不上一款插件，这意味着你可以自由地在Github Page中使用它。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;起源&quot;&gt;起源&lt;/h2&gt;

&lt;p&gt;最主要地原因是我准备写一篇博客展示刚从&lt;a href=&quot;https://www.w3schools.com&quot;&gt;w3school&lt;/a&gt;温习的CSS基础，并将demo的代码和效果一并展示出来。结果发现我认为样式最简洁明快且被广泛认可的&lt;a href=&quot;jsfiddle.net&quot;&gt;jsfiddle&lt;/a&gt;被墙了，更甚至的它一直都没有被&lt;a href=&quot;https://github.com/gfwlist/gfwlist&quot;&gt;gfwlist&lt;/a&gt;项目嗅探到，这意味着一个正常来自中国大陆地区的网民是无法通过直接或使用Shadowsocks Pac模式的方式预览到我提供的demo的，如果我一昧要使用它的话。而其他的embed服务，要么样式太复杂(&lt;a href=&quot;http://codepen.io&quot;&gt;codepen&lt;/a&gt;),要么必须付费(&lt;a href=&quot;https://jsbin.com/&quot;&gt;jsbin&lt;/a&gt;,不得不说我很喜欢jsbin的体验甚至超过jsfiddle)。&lt;/p&gt;

&lt;p&gt;所以，我决定自己做一个。&lt;/p&gt;

&lt;h2 id=&quot;长处&quot;&gt;长处&lt;/h2&gt;

&lt;p&gt;相比较那些由在线服务提供的demo展示工具，jekyll-demos还是有很多先天的优点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;它是免费的，任何人都可以基于MIT许可使用它。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;它是完全是静态且本地（静态网站自身）驱动的。通过Jekyll模板引擎的帮助，你的所有demos都将被有序的索引到。如果Github Page能持续的提供静态站点部署功能，你几乎有一个&lt;strong&gt;有无限存储的demos仓库&lt;/strong&gt;和&lt;strong&gt;免费且永远不会过期的demo展示服务&lt;/strong&gt;，你无须操心更多（如在线服务网站的可访问性，数据存储的费用）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;如果你有稍微看过Jekyll的官方文档（&lt;del&gt;而不是Ruby代码&lt;/del&gt;），你可以很快地部署jekyll-demos，只需3个步骤：
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;demoConf.yml&lt;/code&gt;从项目中拷贝到你自己的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_data&lt;/code&gt;文件夹，并且设置你所有demos的父目录路径&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;demoBaseUrl&lt;/code&gt;。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;list_demos.html&lt;/code&gt;从项目拷贝到你Jekyll环境的任意位置（除了几个有特殊功能的文件夹&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_site&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_drafts&lt;/code&gt;等）。并且在它的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Front Matters&lt;/code&gt;给他一个全局唯一的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id &lt;/code&gt;。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;将项目中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;demos&lt;/code&gt;配置拷贝到你的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;文件，并且填入你刚才设置的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt;。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每次展示你的demo也很方便，只需要3个步骤：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;将你的demo文件夹放入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;demoBaseUrl&lt;/code&gt;下的任意位置。&lt;/li&gt;
      &lt;li&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;demoConf.yml&lt;/code&gt;中注册demo的id和文件夹存放的位置。&lt;/li&gt;
      &lt;li&gt;&lt;del&gt;引入项目提供的Javascript脚本。（这可以一劳永逸地完成，通过使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;layout&lt;/code&gt;）&lt;/del&gt;&lt;/li&gt;
      &lt;li&gt;在你想展现demo的任意页面的任何位置调用项目中提供Javascript函数。
像这样：
        &lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;demo_js&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;EmbedDemo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;89798dasoid&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;在一个demo中支持多个展示页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;最本质的原理就是，虽然静态模板引擎无法在编译时就将特定demo的Url以宏的形式注入到某个js调用当中，但是可以实现简单的所有demo目录列表输出到某个页面。再之后，js请求那个页面，再对比所有demo的详细信息就能明确的定位到demo的目录及其相关文件了。最后创建iframe动态地展示页面，并使用&lt;a href=&quot;https://github.com/codemirror/CodeMirror/&quot;&gt;CodeMirror&lt;/a&gt;高亮显示代码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eMous/__ResourceRepository/master/Jekyll_demos/2019/04/04/1554395612(1).jpg&quot; alt=&quot;seq&quot; /&gt;&lt;/p&gt;
 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2019-04-05T00:00:00+08:00&quot;&gt;
                2019-04-05
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Fri, 05 Apr 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/04/05/MyDemoTool/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/05/MyDemoTool/</guid>
        
        <category>Jekyll</category>
        
        <category>Javascript</category>
        
        <category>tools</category>
        
        <category>homework</category>
        
        
        <category>Jekyll</category>
        
      </item>
    
      <item>
        <title>使用Jekyll创建Github Page博客</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#这是一个开始&quot; id=&quot;markdown-toc-这是一个开始&quot;&gt;这是一个开始&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#why-github-page--jekyll&quot; id=&quot;markdown-toc-why-github-page--jekyll&quot;&gt;Why Github Page + Jekyll&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jekyll&quot; id=&quot;markdown-toc-jekyll&quot;&gt;Jekyll&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#安装&quot; id=&quot;markdown-toc-安装&quot;&gt;安装&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#安装ruby&quot; id=&quot;markdown-toc-安装ruby&quot;&gt;安装Ruby&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#安装jekyll&quot; id=&quot;markdown-toc-安装jekyll&quot;&gt;安装Jekyll&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#相关参考&quot; id=&quot;markdown-toc-相关参考&quot;&gt;相关参考&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#注意事项&quot; id=&quot;markdown-toc-注意事项&quot;&gt;注意事项&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- 这是我的第一个代码显示脚本 -- &lt;script&gt;demo_js.EmbedDemo(&quot;89798dasoid&quot;)&lt;/script&gt; --&gt;

&lt;center&gt;&lt;img alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/03/31/building_website.svg&quot; /&gt;&lt;/center&gt;

&lt;h2 id=&quot;这是一个开始&quot;&gt;这是一个开始&lt;/h2&gt;

&lt;p&gt;由于&lt;a href=&quot;https://caihuashuai.blogspot.com/&quot;&gt;Blogger平台&lt;/a&gt;对于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Markdown&lt;/code&gt;以及相关的代码显示功能没有原生的支持，所以我决定自建站点用于记录我的计算机学习经历。&lt;/p&gt;

&lt;p&gt;再者，将类似于WordPress之类的博客系统在VPS或Cloud上部署会不可避免地随着时间的增长增大相关的维护成本——尤其是&lt;strong&gt;数据安全&lt;/strong&gt;以及&lt;strong&gt;站点的可访问性&lt;/strong&gt;相关的维护。所以就有了这里，部署在Github Page上的基于Jekyll的静态博客。&lt;/p&gt;

&lt;p&gt;我将会在这里记录我所有的IT大方向的学习经历，包括但不限于:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对学习方法本身的探讨&lt;/li&gt;
  &lt;li&gt;各端软件开发相关技术&lt;/li&gt;
  &lt;li&gt;IT范畴内相关原理的科普向解释&lt;/li&gt;
  &lt;li&gt;与查错、纠错相关的记录与探讨&lt;/li&gt;
  &lt;li&gt;程序语言本身的探讨&lt;/li&gt;
  &lt;li&gt;科技生活类的内容
    &lt;ul&gt;
      &lt;li&gt;操作系统下基于已有程序或自实现的各种问题的自动化方案&lt;/li&gt;
      &lt;li&gt;与实物或动手操作相关的科技产品或方案探讨
___&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;why-github-page--jekyll&quot;&gt;Why Github Page + Jekyll&lt;/h2&gt;

&lt;p&gt;其实我之前有尝试使用过多种博客系统来做技术博客，包括WordPress、博客园、Blogger、Hexo(on Github Page)。它们都或多或少地各种存在先天的缺陷，使得我无法&lt;strong&gt;花尽可能少的精力到博客本身维护，花尽可能多的经历到博客内容的创作&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;可以明确地对上述博客系统进行划分：&lt;/p&gt;

&lt;hr /&gt;

&lt;table class=&quot;not_extern&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&amp;nbsp;&lt;/th&gt;
      &lt;th&gt;WordPress&lt;/th&gt;
      &lt;th&gt;博客园&lt;/th&gt;
      &lt;th&gt;Blogger&lt;/th&gt;
      &lt;th&gt;Hexo&lt;/th&gt;
      &lt;th&gt;Jekyll&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;center&gt;需要维护站点&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:red&quot;&gt;✔&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✖&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✖&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✖&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✖&lt;/center&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;center&gt;需要科学上网&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✖&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✖&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:red&quot;&gt;✔&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✖&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✖&lt;/center&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;center&gt;全样式自定义&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✔&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:red&quot;&gt;✖&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:red&quot;&gt;✖&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✔&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✔&lt;/center&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;center&gt;&lt;span title=&quot;广告、社交关系等&quot; style=&quot;text-decoration:underline;&quot;&gt;潜在信息侵入&lt;/span&gt;&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✖&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:red&quot;&gt;✔&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✖&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✖&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✖&lt;/center&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;center&gt;&lt;span title=&quot;Github Page支持自动生成静态页面&quot; style=&quot;text-decoration:underline;&quot;&gt;页面自动生成&lt;/span&gt;&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&amp;nbsp;&lt;/td&gt;
      &lt;td&gt;&amp;nbsp;&lt;/td&gt;
      &lt;td&gt;&amp;nbsp;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:red&quot;&gt;✖&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✔&lt;/center&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;center&gt;站内编辑博客&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✔&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✔&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:green&quot;&gt;✔&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:red&quot;&gt;✖&lt;/center&gt;&lt;/td&gt;
      &lt;td&gt;&lt;center style=&quot;color:red&quot;&gt;✖&lt;/center&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;p&gt;对我来说，最重要的是&lt;strong&gt;是否需要维护站点&lt;/strong&gt;。数据安全是最重要的，哪怕这些数据都是裸着公布出来的，我也一点也不希望它被添加、篡改或删除；其次才是站点地可用性：宕机的可能性、如何配置安全策略从而避免被流量攻击等等，虽然这些大多都是一劳永逸的，但至少目前对于我来说我并没有在互联网上能够看到一个&lt;strong&gt;对个人站点适用的，能避免绝大多数内部问题和外部攻击的策略与相关配置流程&lt;/strong&gt;，更何况像Bandwagon这类的VPS基本上“例行性”的宕机且&lt;strong&gt;隐藏着各种复杂的内部用户条款——有一万个理由挂起你的服务器&lt;/strong&gt;。没有一个在职的维护人员配合，在这种需要随时应对问题的平台上进行内容创作与管理是一件极其费心的一件事。&lt;/p&gt;

&lt;h2 id=&quot;jekyll&quot;&gt;Jekyll&lt;/h2&gt;

&lt;center&gt;&lt;img alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/03/31/logo-2x.png&quot; /&gt;&lt;/center&gt;

&lt;p&gt;使用Jekyll在Github Page上进行博客创作是Github官方推荐的Page的使用方式之一。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you use Jekyll as a static site generator with GitHub Pages, you benefit from more support with setting up, updating, and troubleshooting your site.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Github Page支持将用户提交的post自动处理成静态页面，这就意味着在你配置好Jekyll后，你只需要一个Git和一个文本编辑器&lt;small&gt;(&lt;del&gt;而不需要本地的Jekyll环境，虽然它确实在预览页面上能提供很大的帮助&lt;/del&gt;)&lt;/small&gt;就能随时地发布新的文章和管理从前发布的文章。&lt;/p&gt;

&lt;p&gt;它基于Ruby编写，在项目的根目录用户可以通过配置文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;操控Jekyll的行为。总体上的&lt;strong&gt;仅改变配置文件和编辑模板文件&lt;/strong&gt;你可以用Jekyll实现以下一些功能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;被动地使用页面模板导出页面:&lt;a href=&quot;https://jekyllrb.com/docs/layouts/&quot;&gt;layout&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;主动地使用页面模板导出页面:&lt;a href=&quot;https://jekyllrb.com/docs/includes/&quot;&gt;include&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;处理存于文件中的静态数据:&lt;a href=&quot;https://jekyllrb.com/docs/datafiles/&quot;&gt;Data Files&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;获取博客相关的元信息:&lt;a href=&quot;https://jekyllrb.com/docs/variables/&quot;&gt;Variables&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;在模板内部进行变量定义、流程控制、过滤器操作等从而控制导出的结果:&lt;a href=&quot;https://jekyllrb.com/docs/liquid/&quot;&gt;Liquid&lt;/a&gt;(模板语言)&lt;/li&gt;
  &lt;li&gt;分页、主题、插件等&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;

&lt;p&gt;&lt;small&gt;&lt;del&gt;如果你只想快捷地写博客你其实并不需要安装Jeykll，甚至你可以直接Git clone我的项目，再把我的/_posts下的文章删去，按照我的格式直接Push你自己的文章即可。&lt;/del&gt; &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;由于目前我是用的是Windows平台，故该文档只有Windows平台的参考。下面是我的操作陈述，如有冗余操作请在下方告诉我，谢谢。&lt;/p&gt;

&lt;h4 id=&quot;安装ruby&quot;&gt;安装Ruby&lt;/h4&gt;

&lt;p&gt;进入&lt;a href=&quot;https://www.ruby-lang.org/en/downloads/&quot;&gt;RubyInstaller下载页面&lt;/a&gt;下载Installer &lt;strong&gt;with Devkit&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;勾选toolchain。&lt;/p&gt;
&lt;center&gt;&lt;img alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/03/31/1554021299.jpg&quot; /&gt;&lt;/center&gt;

&lt;p&gt;安装完成后，Ruby将存放在C盘根目录，勾选“Run ridk install ……”并finishh，将弹出下图所示命令窗口，输入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3&lt;/code&gt;并回车。&lt;/p&gt;
&lt;center&gt;&lt;img alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/03/31/Snipaste_2019-03-31_16-39-33.png&quot; /&gt;&lt;/center&gt;

&lt;p&gt;最后将提示: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Install MSYS2 and MINGW development toolchain succeeded&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;安装jekyll&quot;&gt;安装Jekyll&lt;/h4&gt;
&lt;p&gt;进入任何一个你想安装博客的文件夹（这会是最终项目目录的父文件夹），&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift+右键打开Powershell&lt;/code&gt;输入:&lt;/p&gt;
&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;gem&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;install&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;jekyll&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bundler&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Jekyll和bundler安装完毕以后，可以通过Jekyll创建一个带有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;minima&lt;/code&gt;主题的博客。&lt;/p&gt;

&lt;p&gt;运行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jeykll s&lt;/code&gt;，再访问localhost:4000，你就能看到自己的博客了！&lt;/p&gt;
&lt;center&gt;&lt;img alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/03/31/Snipaste_2019-03-31_17-21-34.png&quot; /&gt;&lt;/center&gt;

&lt;p&gt;再之后，你只需要在_posts文件夹中添加形如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y-m-d-name&lt;/code&gt;格式的文件，即可实时浏览到你的新文章了。&lt;/p&gt;

&lt;h2 id=&quot;相关参考&quot;&gt;相关参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/en/articles/configuring-jekyll-plugins&quot;&gt;原生Github Page&lt;strong&gt;仅&lt;/strong&gt;支持的Jekyll插件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jekyllrb.com/docs/variables/&quot;&gt;Jekyll元变量属性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.rubydoc.info/github/mojombo/jekyll/Jekyll&quot;&gt;Jekyll Ruby程序相关ref&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;注意事项&quot;&gt;注意事项&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;修改配置文件后重新运行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jekyll s&lt;/code&gt;。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;不要使用中文文件名。&lt;/strong&gt;
如果你有在Windows环境下预览博客的需求，请不要使用中文设置你的文件名。否则，URL中会带有中文并以UTF-8的编码形式回传给Jekyll，而它的服务端程序默认接受的是GB2312编码的数据，这时就会出现某个乱码位置无法被找到的错误。与其修改Jekyll程序的源码，我更推荐你不要使用中文给文件命名，毕竟文件名和文章的title不是必须相同的。&lt;/li&gt;
  &lt;li&gt;如果你的bundle假死，可以尝试修改&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gemfile&lt;/code&gt;文件的第一行:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;source &quot;https://gems.ruby-china.com/&quot;&lt;/code&gt;
默认情况下运行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jekyll s&lt;/code&gt;会提供&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;导出静态文件(jekyll b)&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;为博客提供HTTP服务&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;（除了_site文件夹外的）文件变动自动重新生成（到_site文件夹内）&lt;/code&gt;的功能。但是，如果修改了配置文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;就必须手动重新导出静态文件。&lt;/li&gt;
  &lt;li&gt;文章提交后Github Page或许需要一会才会有变化，尤其是css。&lt;/li&gt;
  &lt;li&gt;如果favicon变更了，发现页面的不论如何删除缓存都还是旧的，试试&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift + Ctrl + R&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;_posts里的文章必须形如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y-m-d-name&lt;/code&gt;，如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2019-3-31&lt;/code&gt;，否则将无法被识别。&lt;/li&gt;
  &lt;li&gt;scss文件中如果出现UTF-8编码的中文无法通过本地的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jekyll b&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;对于一个带有Front Matters的页面，如果它不在Collection中(包括include、post)。那么，其他页面通过Page.content获得它的内容将是Unrendered的并且无法手动Render。相反的，如果在Collection中，则可以获得到的是已经渲染过的。&lt;/li&gt;
&lt;/ol&gt;
 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2018-03-31T00:00:00+08:00&quot;&gt;
                2018-03-31
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Sat, 31 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/31/Beginning/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/31/Beginning/</guid>
        
        <category>Liquid</category>
        
        <category>RSS</category>
        
        <category>Gem</category>
        
        <category>Jekyll</category>
        
        <category>YAML</category>
        
        
        <category>Jekyll</category>
        
      </item>
    
      <item>
        <title>重新认识SSH（二）</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#channel机制&quot; id=&quot;markdown-toc-channel机制&quot;&gt;Channel机制&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#新建打开一个channel&quot; id=&quot;markdown-toc-新建打开一个channel&quot;&gt;（新建）打开一个Channel&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#传输数据&quot; id=&quot;markdown-toc-传输数据&quot;&gt;传输数据&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#关闭channel&quot; id=&quot;markdown-toc-关闭channel&quot;&gt;关闭Channel&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#明确channel信息请求&quot; id=&quot;markdown-toc-明确channel信息请求&quot;&gt;明确Channel信息请求&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#交互session&quot; id=&quot;markdown-toc-交互session&quot;&gt;交互Session&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#打开session-channel&quot; id=&quot;markdown-toc-打开session-channel&quot;&gt;打开Session Channel&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#请求一个虚拟终端&quot; id=&quot;markdown-toc-请求一个虚拟终端&quot;&gt;请求一个虚拟终端&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#x11转发&quot; id=&quot;markdown-toc-x11转发&quot;&gt;X11转发&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#传递环境变量&quot; id=&quot;markdown-toc-传递环境变量&quot;&gt;传递环境变量&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#启动一个shell或者一个命令&quot; id=&quot;markdown-toc-启动一个shell或者一个命令&quot;&gt;启动一个Shell或者一个命令&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#窗口调整消息&quot; id=&quot;markdown-toc-窗口调整消息&quot;&gt;窗口调整消息&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#本地流控&quot; id=&quot;markdown-toc-本地流控&quot;&gt;本地流控&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#信号&quot; id=&quot;markdown-toc-信号&quot;&gt;信号&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#返回退出状态&quot; id=&quot;markdown-toc-返回退出状态&quot;&gt;返回退出状态&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tcpip-端口转发&quot; id=&quot;markdown-toc-tcpip-端口转发&quot;&gt;TCP/IP 端口转发&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#全局请求&quot; id=&quot;markdown-toc-全局请求&quot;&gt;全局请求&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#请求端口转发&quot; id=&quot;markdown-toc-请求端口转发&quot;&gt;请求端口转发&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tcpip转发channel&quot; id=&quot;markdown-toc-tcpip转发channel&quot;&gt;TCP/IP转发Channel&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#终端模式的编码&quot; id=&quot;markdown-toc-终端模式的编码&quot;&gt;终端模式的编码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#预定义名称&quot; id=&quot;markdown-toc-预定义名称&quot;&gt;预定义名称&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#连接协议channel类型&quot; id=&quot;markdown-toc-连接协议channel类型&quot;&gt;连接协议Channel类型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#连接协议全局请求名&quot; id=&quot;markdown-toc-连接协议全局请求名&quot;&gt;连接协议全局请求名&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#连接协议channel明细请求名&quot; id=&quot;markdown-toc-连接协议channel明细请求名&quot;&gt;连接协议Channel明细请求名&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#连接协议子系统名&quot; id=&quot;markdown-toc-连接协议子系统名&quot;&gt;连接协议子系统名&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#reference&quot; id=&quot;markdown-toc-reference&quot;&gt;Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;https://ss.caihuashuai.com/StaticData/Blog/SSH/SSH_logo.png&quot; /&gt;&lt;/div&gt;

&lt;p&gt;在认证完毕后，客户端和服务端之间将使用SSH连接协议进行实际的任务操作，包括&lt;strong&gt;开启交互式的登录会话&lt;/strong&gt;、&lt;strong&gt;远程命令调用&lt;/strong&gt;、&lt;strong&gt;TCP转发&lt;/strong&gt;、&lt;strong&gt;X11转发&lt;/strong&gt;等。在传输层协议之上，启用连接协议的方式就是请求一个&lt;strong&gt;service name&lt;/strong&gt;为&lt;strong&gt;ssh-connection&lt;/strong&gt;服务。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;channel机制&quot;&gt;Channel机制&lt;/h2&gt;

&lt;p&gt;连接协议里的每个实际应用都是Channel，各方都有可能打开Channel，大量的Channel复用同一个Connection（我认为这里指的Connection应该是上文说的ssh-connection service）。一个Channel被双方用自己的数字标识，所以每端不同的数字可能指向的并不是相同的Channel。其他任何和Channel相关的消息都会包含对端的Channel标识。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sender:number1    -&amp;gt;    ()=========================()    &amp;lt;-    number2:receiver
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Channel是被&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;流控&lt;/code&gt;的，在被告知&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;窗口&lt;/code&gt;可用之前没有数据可以在Channel里传输。&lt;/p&gt;

&lt;h3 id=&quot;新建打开一个channel&quot;&gt;（新建）打开一个Channel&lt;/h3&gt;

&lt;p&gt;当任意一端想要新建一个Channel时，它首先要给Channel分配一个本端的数字标识。然后将下面的消息发送给对端，这个消息包括了本（发送）端标识、初始化窗口大小等。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_OPEN
      string    channel type in US-ASCII only
      uint32    sender channel
      uint32    initial window size
      uint32    maximum packet size
      ....      channel type specific data follows
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;channel type&lt;/code&gt;是一个名字，符合SSH rfc命名规范，注册命名(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;名称&lt;/code&gt;)、扩展命名（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;名称@域名&lt;/code&gt;）；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sender channel&lt;/code&gt;是本地的标识；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;initial window size&lt;/code&gt;则明确了&lt;strong&gt;在不调整窗口大小的情况下，对方一共可以发送多少字节的数据给（这个消息的）发送者&lt;/strong&gt;；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;maximum packet size&lt;/code&gt;表示对方发给 &lt;strong&gt;(这个消息的)发送者&lt;/strong&gt; 的单次的packet的最大值是多少。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么要设置window size和maximum packet size&lt;/strong&gt;，我的理解是，有一些老旧的慢速设备IO带宽很低，所以如果大量的数据涌进来会导致缓冲区溢出。&lt;/p&gt;

&lt;p&gt;对端收到消息后需要作出决定是否同意开启一个Channel，使用SSH_MSG_CHANNEL_OPEN_CONFIRMATION或SSH_MSG_CHANNEL_OPEN_FAILURE响应消息。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_OPEN_CONFIRMATION
      uint32    recipient channel
      uint32    sender channel
      uint32    initial window size
      uint32    maximum packet size
      ....      channel type specific data follows
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recipient channel&lt;/code&gt;为&lt;strong&gt;请求开启Channel端&lt;/strong&gt;的本地Channel标识，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sender channel&lt;/code&gt;则为&lt;strong&gt;当前消息发送方&lt;/strong&gt;的本地Channel标识，其他的数据都是描述&lt;strong&gt;当前消息发送方&lt;/strong&gt;的。或者发送打开失败的消息SSH_MSG_CHANNEL_OPEN_FAILURE。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_OPEN_FAILURE
      uint32    recipient channel
      uint32    reason code
      string    description in ISO-10646 UTF-8 encoding [RFC3629]
      string    language tag [RFC3066]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;比如&lt;strong&gt;被请求开启Channel的一方&lt;/strong&gt;不支持标注的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;channel type&lt;/code&gt;，那它将简单地回应SSH_MSG_CHANNEL_OPEN_FAILURE。请求方则或许需要显示&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;description&lt;/code&gt;给用户。下面是一些预定义的错误码：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;            SSH_OPEN_ADMINISTRATIVELY_PROHIBITED          1
            SSH_OPEN_CONNECT_FAILED                       2
            SSH_OPEN_UNKNOWN_CHANNEL_TYPE                 3
            SSH_OPEN_RESOURCE_SHORTAGE                    4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;错误码0x00000005 - 0xFDFFFFFF将按照&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IETF CONSENSUS&lt;/code&gt;的方式分配，0xFE000000 - 0xFFFFFFFF则留给个人使用。虽然IANA没有关于0xFE000000 - 0xFFFFFFFF的控制权，但是还是将他约定成2部分使用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;0xFE000000 - 0xFEFFFFFF被用在本地分配的Channel上，比如channel type为”example_session@example.com”(带有@符号)的Channel打开失败，那么错误码应该使用由IANA分配的部分（ 0x00000001 - 0xFDFFFFFF）或者本地分配相关的部分（0xFE000000 - 0xFEFFFFFF）。&lt;/p&gt;

    &lt;p&gt;比如服务器不认识这个channel type，哪怕这个type是本地定义（包含@）的，也必须使用0x00000003错误码。然而如果，服务器认识这个错误码但是无法打开，则应该使用0xFE000000 - 0xFEFFFFFF其中的一个错误码。总的来说，参与者应该首先尝试使用IANA分配的错误码，然后在使用它们自定义的原因。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于从0xFF开始的部分，不做限制或建议。在这个范围内的每一个值，都不被期望有任何实际操作交互性，本质上说它们是为实验目的而预留的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;传输数据&quot;&gt;传输数据&lt;/h3&gt;

&lt;p&gt;上文描述了窗口大小可以用来限制另一方发送的数据量，同时协议规定双方都可以通过下面的消息对窗口作出调整。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_WINDOW_ADJUST
      uint32    recipient channel
      uint32    bytes to add
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;接收方接收到这个消息以后，接收方可以根据这个给定的数增加窗口的大小，不论如何窗口最大为2^32-1字节。具体的数据，则通过下面的消息发送。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_DATA
      uint32    recipient channel
      string    data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;单次可以发送数据的最大量取决于&lt;strong&gt;对方当前窗口尺寸&lt;/strong&gt;和&lt;strong&gt;对方允许接受的最大packet值&lt;/strong&gt;的最小值。对方每接受一个消息，窗口都会相应减少。规范期望实现可以对传输层packet size做出限制（任何关于接受数据的限制必须大于等于32768字节）。所以在连接层协议：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;不准将可接受的maximum packet size设置成大于传输层能接受的最大值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不准生成超过传输层能发送的最大值，哪怕对方的连接协议能接受这么大的packet。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时，协议提供了一些传递额外数据（比如stderr数据）的方法。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_EXTENDED_DATA
      uint32    recipient channel
      uint32    data_type_code
      string    data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;目前标准定义的data_type_code类型有：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;             SSH_EXTENDED_DATA_STDERR               1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;同时这个data_type_code的值的分发规定也与上文的channel type类似，分为IANA部分和私人使用部分。&lt;/p&gt;

&lt;h3 id=&quot;关闭channel&quot;&gt;关闭Channel&lt;/h3&gt;

&lt;p&gt;当任意一方不在往Channel发送更多数据的时候，它应该发送一个SSH_MSG_CHANNEL_EOF消息。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_EOF
      uint32    recipient channel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个消息不会有明确的响应，但是它依旧应该被发送给对方不论对方是谁。需要注意的是，发送完这个消息后，Channel依旧是打开着的（只不过自己这一边不再发数据了），从另一个方向上还是可能过来更多的数据。这个消息并不会消耗窗口大小，即使窗口已经不可以。&lt;/p&gt;

&lt;p&gt;当任意一方希望结束Channel时，则应该发送SSH_MSG_CHANNEL_CLOSE。另一方必须也发送SSH_MSG_CHANNEL_CLOSE，除非它已经发送过SSH_MSG_CHANNEL_CLOSE（网络延迟）了。当一方&lt;strong&gt;既发送了又接收到&lt;/strong&gt;SSH_MSG_CHANNEL_CLOSE消息，Channel就被关闭了，相关的资源可以被清理，本地的Channel number可以在下次打开Channel的时候重用。任意一方都可以直接发送SSH_MSG_CHANNEL_CLOSE而不需要与现发送SSH_MSG_CHANNEL_EOF。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_CLOSE
      uint32    recipient channel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;同样的，这个消息不需要消耗窗口大小。&lt;/p&gt;

&lt;h3 id=&quot;明确channel信息请求&quot;&gt;明确Channel信息请求&lt;/h3&gt;

&lt;p&gt;许多的channel type包含关于该channel type的更详细的扩充设定。比如说，为一个交互session请求一个虚拟终端。所有的明确Channel信息请求都是如下格式。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_REQUEST
      uint32    recipient channel
      string    request type in US-ASCII characters only
      boolean   want reply
      ....      type-specific data follows
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;want reply&lt;/code&gt;被设置成FALSE，不会有响应被回复给请求端。否则，响应可能包括SSH_MSG_CHANNEL_SUCCESS、SSH_MSG_CHANNEL_FAILURE或者要求继续提供信息的消息。如果接收端不认识或不支持这个扩充的明细，则返回SSH_MSG_CHANNEL_FAILURE。&lt;/p&gt;

&lt;p&gt;这个消息也不消耗窗口大小，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request type&lt;/code&gt;是自定义的。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_SUCCESS
      uint32    recipient channel


      byte      SSH_MSG_CHANNEL_FAILURE
      uint32    recipient channel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上述两个消息也不消耗窗口大小。&lt;/p&gt;

&lt;h2 id=&quot;交互session&quot;&gt;交互Session&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;一个Session就是一个远程的程序的执行&lt;/strong&gt;。这个程序或许是shell、应用程序、系统调用或者内建的子系统。它可能没有绑定到虚拟终端上，又或者有或没有涉及到X11转发。同时间，可以有多个Session正在被运行。&lt;/p&gt;

&lt;h3 id=&quot;打开session-channel&quot;&gt;打开Session Channel&lt;/h3&gt;

&lt;p&gt;使用如下消息打开一个Session Channel，客户端应该拒绝来自服务端的打开Session Channel的请求以避免被攻击。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_OPEN
      string    &quot;session&quot;
      uint32    sender channel
      uint32    initial window size
      uint32    maximum packet size
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;请求一个虚拟终端&quot;&gt;请求一个虚拟终端&lt;/h3&gt;

&lt;p&gt;通过如下消息可以让服务器为Session分配一个虚拟终端，character/row的优先级相比于pixels更高，除非他们被设置成0。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_REQUEST
      uint32    recipient channel
      string    &quot;pty-req&quot;
      boolean   want_reply
      string    TERM environment variable value (e.g., vt100)
      uint32    terminal width, characters (e.g., 80)
      uint32    terminal height, rows (e.g., 24)
      uint32    terminal width, pixels (e.g., 640)
      uint32    terminal height, pixels (e.g., 480)
      string    encoded terminal modes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;客户端应该拒绝来自服务端的虚拟终端明确信息请求以避免被攻击。&lt;/p&gt;

&lt;h3 id=&quot;x11转发&quot;&gt;X11转发&lt;/h3&gt;

&lt;p&gt;通过如下消息可以为Session请求X11转发。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_REQUEST
      uint32    recipient channel
      string    &quot;x11-req&quot;
      boolean   want reply
      boolean   single connection
      string    x11 authentication protocol
      string    x11 authentication cookie
      uint32    x11 screen number
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;协议推荐将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x11 authentication cookie&lt;/code&gt;发送成一个虚假且随机的cookie，知道连接消息被接收后它将被检验并替换成真实的cookie。当session channel被关闭的时候，X11转发也应该停止，但是已经打开的转发不应该自动被关闭。如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;single connection&lt;/code&gt;被设置为TRUE，那么只有一个连接被转发。&lt;/p&gt;

&lt;p&gt;这个消息对应的操作是： 客户端向服务器发出请求，服务器在本地新建N个（如果single connection不为0）X11服务器（只是纯粹的监听6000+server自定义offset（openssh为10）的TCP端口，创建相应的DISPLAY环境变量）。&lt;/p&gt;

&lt;p&gt;在remote session上执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gedit &amp;amp;&lt;/code&gt;时，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gedit&lt;/code&gt;是符合X11协议的客户端，所以它会检测环境变量发现存在display，就和本地的6010端口建立连接。服务器的伪x11服务器socket侦测到连接就很向客户端发起SSH_MSG_CHANNEL_OPEN x11 Channel的请求。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_OPEN
      string    &quot;x11&quot;
      uint32    sender channel
      uint32    initial window size
      uint32    maximum packet size
      string    originator address (e.g., &quot;192.168.7.38&quot;)
      uint32    originator port
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;客户端收到请求后再与本地的X11建立连接，这样一个X11转发的通道就完成了（我并没有在openssh的源码中发现客户端是如何使用originator address数据的）。&lt;/p&gt;

&lt;h3 id=&quot;传递环境变量&quot;&gt;传递环境变量&lt;/h3&gt;

&lt;p&gt;在shell或command被开始时之后，或许有环境变量需要被传递过去。然而在特权程序里不受控制的设置环境变量是一个很有风险的事情，所以规范推荐实现维护一个允许被设置的环境变量列表或者只有当sshd丢弃权限后设置环境变量。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_REQUEST
      uint32    recipient channel
      string    &quot;env&quot;
      boolean   want reply
      string    variable name
      string    variable value
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;启动一个shell或者一个命令&quot;&gt;启动一个Shell或者一个命令&lt;/h3&gt;

&lt;p&gt;一旦一个Session被设置完毕，在远端就会有一个程序被启动。这个程序可以是一个Shell，也可以时一个应用程序或者是一个有着独立域名的子系统。下面的请求每个Channel（Session）只允许设置一个。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_REQUEST
      uint32    recipient channel
      string    &quot;shell&quot;
      boolean   want reply

      byte      SSH_MSG_CHANNEL_REQUEST
      uint32    recipient channel
      string    &quot;exec&quot;
      boolean   want reply
      string    command

      byte      SSH_MSG_CHANNEL_REQUEST
      uint32    recipient channel
      string    &quot;subsystem&quot;
      boolean   want reply
      string    subsystem name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;窗口调整消息&quot;&gt;窗口调整消息&lt;/h3&gt;

&lt;p&gt;当客户端的终端窗口大小被改变时，或许需要发送这个消息给服务器。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_REQUEST
      uint32    recipient channel
      string    &quot;window-change&quot;
      boolean   FALSE
      uint32    terminal width, columns
      uint32    terminal height, rows
      uint32    terminal width, pixels
      uint32    terminal height, pixels
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个消息没有响应。&lt;/p&gt;

&lt;h3 id=&quot;本地流控&quot;&gt;本地流控&lt;/h3&gt;

&lt;p&gt;在很多系统中，这是否可行取决于伪终端是否使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;control-S/control-Q&lt;/code&gt;进行流控。如果正在使用，那么在客户端就应该有一个流控的功能给服务端的响应提速，这还是取决于服务端设备的（系统）实现。下面的消息可以让服务器通知客户端是否可以提供流控的功能，如果可以的话客户端则可以使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;control-S/control-Q&lt;/code&gt;进行流控。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_REQUEST
      uint32    recipient channel
      string    &quot;xon-xoff&quot;
      boolean   FALSE
      boolean   client can do
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个消息没有响应。&lt;/p&gt;

&lt;h3 id=&quot;信号&quot;&gt;信号&lt;/h3&gt;

&lt;p&gt;一个信号可以被传输给远端的程序或服务使用下面的消息。有一些系统可能没有实现信号，所以那些系统下的服务端应该忽略这个消息。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_REQUEST
      uint32    recipient channel
      string    &quot;signal&quot;
      boolean   FALSE
      string    signal name (without the &quot;SIG&quot; prefix)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signal name&lt;/code&gt;在下面的预定义名称中有描述。&lt;/p&gt;

&lt;h3 id=&quot;返回退出状态&quot;&gt;返回退出状态&lt;/h3&gt;

&lt;p&gt;当在远端的命令结束时，下面的消息可以用来传递其退出的状态码。发送或收到这个消息后Channel将被关闭。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_REQUEST
      uint32    recipient channel
      string    &quot;exit-status&quot;
      boolean   FALSE
      uint32    exit_status
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;同时远端的程序也可能因为一个信号而被迫关闭(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exit_statue&lt;/code&gt; 为0的时候为正常关闭)，这个情况下下面的消息将被发送。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_REQUEST
      uint32    recipient channel
      string    &quot;exit-signal&quot;
      boolean   FALSE
      string    signal name (without the &quot;SIG&quot; prefix)
      boolean   core dumped
      string    error message in ISO-10646 UTF-8 encoding
      string    language tag [RFC3066]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tcpip-端口转发&quot;&gt;TCP/IP 端口转发&lt;/h2&gt;

&lt;h3 id=&quot;全局请求&quot;&gt;全局请求&lt;/h3&gt;

&lt;p&gt;协议规定了许多种可以影响远端全局而独立于任何Channel的请求，一个例子就是唯一个特定的端口请求TCP/IP转发。双方中的任意一方都有可能在任意时间发送全局请求，接收方必须做出合理的响应，其格式如下。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_GLOBAL_REQUEST
      string    request name in US-ASCII only
      boolean   want reply
      ....      request-specific data follows
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;响应如下，通常不包含&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;response specific data&lt;/code&gt;这一栏。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_REQUEST_SUCCESS
      ....     response specific data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;协议规定，SSH_MSG_GLOBAL_REQUESTS的响应顺序必须如其发送顺序一致。有明确指示Channel的请求消息才可以不按顺序发送。&lt;/p&gt;
&lt;h3 id=&quot;请求端口转发&quot;&gt;请求端口转发&lt;/h3&gt;

&lt;p&gt;如果其中一方期望&lt;strong&gt;一个发往对方端口的数据可以转发到本地的端口&lt;/strong&gt;，那么他可以发送如下的请求。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_GLOBAL_REQUEST
      string    &quot;tcpip-forward&quot;
      boolean   want reply
      string    address to bind (e.g., &quot;0.0.0.0&quot;)
      uint32    port number to bind
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;address to bind&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;port number to bind&lt;/code&gt;用来标明哪个具体的IP地址（或域名）和端口用于转发（另一端端开启对哪个IP和端口的监听并转发到本地），&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;address to bind&lt;/code&gt;满足以下的语法规则。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;&quot;&lt;/code&gt;表示接受所有的被SSH实现方支持的协议。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;0.0.0.0&quot;&lt;/code&gt;表示监听所有IPv4端口。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;::&quot;&lt;/code&gt;表示监听所有IPv6端口。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;localhost&quot;&lt;/code&gt;表示在回环网卡上监听所有被SSH实现支持的协议。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;127.0.0.1&quot;&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;::1&quot;&lt;/code&gt;分别表示监听IPv4和IPv6的回环网卡。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;客户端应该拒绝这个消息，这个消息一般只允许客户端发送。同时如果客户端传递的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;port number&lt;/code&gt;是0，且它设置了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;want reply&lt;/code&gt;为TRUE，那么服务器应该分配下一个可用的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;非权限端口&lt;/code&gt;，并且在响应中告知客户端。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte     SSH_MSG_REQUEST_SUCCESS
      uint32   port that was bound on the server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;端口转发可以被下面的消息取消，一个channel open请求可能会直到接收到该消息的响应后收到。这个消息只有客户端可以发送。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_GLOBAL_REQUEST
      string    &quot;cancel-tcpip-forward&quot;
      boolean   want reply
      string    address_to_bind (e.g., &quot;127.0.0.1&quot;)
      uint32    port number to bind
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;tcpip转发channel&quot;&gt;TCP/IP转发Channel&lt;/h3&gt;

&lt;p&gt;当服务端被设置需要监听并转发的端口收到了外部的连接时，服务端将发送下面的消息请求客户端开启一个TCP/IP转发Channel。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_OPEN
      string    &quot;forwarded-tcpip&quot;
      uint32    sender channel
      uint32    initial window size
      uint32    maximum packet size
      string    address that was connected （外部连接到服务器监听地址的的IP地址）
      uint32    port that was connected 
      string    originator IP address (这个应该是服务端监听的地址)
      uint32    originator port
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;客户端应该比对是否向服务器请求了originator port的TCP/IP端口转发。&lt;/p&gt;

&lt;p&gt;当客户端本地的TCP/IP转发端口接收到来自外部的连接（这个监听端口是客户端主动打开的）时，客户端发送如下消息给服务器转发这个TCP/IP数据。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      byte      SSH_MSG_CHANNEL_OPEN
      string    &quot;direct-tcpip&quot;
      uint32    sender channel
      uint32    initial window size
      uint32    maximum packet size
      string    host to connect
      uint32    port to connect
      string    originator IP address
      uint32    originator port
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;host to connect&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;port to connect&lt;/code&gt;表示服务端内部需要建立一个通往&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;host to connect&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;port to connect&lt;/code&gt;的连接。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;originator IP address&lt;/code&gt;表示客户端监听到的连接发起于哪个外部IP地址、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;originator port&lt;/code&gt;表示客户端监听到的连接发起于哪个外部主机的端口。&lt;/p&gt;

&lt;p&gt;转发Channel独立于Session存在，Session关闭并不意味着转发Channel也要被关闭。客户端应该拒绝&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;direct-tcpip&lt;/code&gt;请求。&lt;/p&gt;

&lt;h2 id=&quot;终端模式的编码&quot;&gt;终端模式的编码&lt;/h2&gt;

&lt;p&gt;在请求一个终端的时候会用到终端模式的编码（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;encoded terminal modes&lt;/code&gt;），它们被编码进字节流里。这是为了他们可以方便地在不同环境间传输。字节流包括以字节为值地操作码构成地参数对。1-159的操作码时uint32类型的参数，160-255还未被定义，并且如果遇到它们应该停止解析。字节流被操作码&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TTY_OP_END(0x00)&lt;/code&gt;终止。&lt;/p&gt;

&lt;p&gt;客户端应该尽可能的把它知道的模式操作码加入字节流中，而服务器对于它不知道的模式应该忽略。至少在用类POSIX 虚拟终端的系统间，会支持一些机器无关的特性。这个协议也能支持其他的系统，但是客户端或许需要补充一系列合理的参数数值这样服务器才能为伪终端提供合理的模式。具体预定义数值如下（为了可读性，将Byte写成了数字）：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;          opcode  mnemonic       description
          ------  --------       -----------
          0     TTY_OP_END  Indicates end of options.
          1     VINTR       Interrupt character; 255 if none.  Similarly
                             for the other characters.  Not all of these
                             characters are supported on all systems.
          2     VQUIT       The quit character (sends SIGQUIT signal on
                             POSIX systems).
          3     VERASE      Erase the character to left of the cursor.
          4     VKILL       Kill the current input line.
          5     VEOF        End-of-file character (sends EOF from the
                             terminal).
          6     VEOL        End-of-line character in addition to
                             carriage return and/or linefeed.
          7     VEOL2       Additional end-of-line character.
          8     VSTART      Continues paused output (normally
                             control-Q).
          9     VSTOP       Pauses output (normally control-S).
          10    VSUSP       Suspends the current program.
          11    VDSUSP      Another suspend character.
                    12    VREPRINT    Reprints the current input line.
          13    VWERASE     Erases a word left of cursor.
          14    VLNEXT      Enter the next character typed literally,
                             even if it is a special character
          15    VFLUSH      Character to flush output.
          16    VSWTCH      Switch to a different shell layer.
          17    VSTATUS     Prints system status line (load, command,
                             pid, etc).
          18    VDISCARD    Toggles the flushing of terminal output.
          30    IGNPAR      The ignore parity flag.  The parameter
                             SHOULD be 0 if this flag is FALSE,
                             and 1 if it is TRUE.
          31    PARMRK      Mark parity and framing errors.
          32    INPCK       Enable checking of parity errors.
          33    ISTRIP      Strip 8th bit off characters.
          34    INLCR       Map NL into CR on input.
          35    IGNCR       Ignore CR on input.
          36    ICRNL       Map CR to NL on input.
          37    IUCLC       Translate uppercase characters to
                             lowercase.
          38    IXON        Enable output flow control.
          39    IXANY       Any char will restart after stop.
          40    IXOFF       Enable input flow control.
          41    IMAXBEL     Ring bell on input queue full.
          50    ISIG        Enable signals INTR, QUIT, [D]SUSP.
          51    ICANON      Canonicalize input lines.
          52    XCASE       Enable input and output of uppercase
                             characters by preceding their lowercase
                             equivalents with &quot;\&quot;.
          53    ECHO        Enable echoing.
          54    ECHOE       Visually erase chars.
          55    ECHOK       Kill character discards current line.
          56    ECHONL      Echo NL even if ECHO is off.
          57    NOFLSH      Don&apos;t flush after interrupt.
          58    TOSTOP      Stop background jobs from output.
          59    IEXTEN      Enable extensions.
          60    ECHOCTL     Echo control characters as ^(Char).
          61    ECHOKE      Visual erase for line kill.
          62    PENDIN      Retype pending input.
          70    OPOST       Enable output processing.
          71    OLCUC       Convert lowercase to uppercase.
          72    ONLCR       Map NL to CR-NL.
          73    OCRNL       Translate carriage return to newline
                             (output).
          74    ONOCR       Translate newline to carriage
                             return-newline (output).
          75    ONLRET      Newline performs a carriage return
                             (output).
          90    CS7         7 bit mode.
          91    CS8         8 bit mode.
          92    PARENB      Parity enable.
          93    PARODD      Odd parity, else even.

          128 TTY_OP_ISPEED  Specifies the input baud rate in
                              bits per second.
          129 TTY_OP_OSPEED  Specifies the output baud rate in
                              bits per second.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;预定义名称&quot;&gt;预定义名称&lt;/h2&gt;

&lt;h3 id=&quot;连接协议channel类型&quot;&gt;连接协议Channel类型&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;         Channel type                  Reference
         ------------                  ---------
         session                       [SSH-CONNECT, Section 6.1]
         x11                           [SSH-CONNECT, Section 6.3.2]
         forwarded-tcpip               [SSH-CONNECT, Section 7.2]
         direct-tcpip                  [SSH-CONNECT, Section 7.2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;连接协议全局请求名&quot;&gt;连接协议全局请求名&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;         Request type                  Reference
         ------------                  ---------
         tcpip-forward                 [SSH-CONNECT, Section 7.1]
         cancel-tcpip-forward          [SSH-CONNECT, Section 7.1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;连接协议channel明细请求名&quot;&gt;连接协议Channel明细请求名&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;         Request type                  Reference
         ------------                  ---------
         pty-req                       [SSH-CONNECT, Section 6.2]
         x11-req                       [SSH-CONNECT, Section 6.3.1]
         env                           [SSH-CONNECT, Section 6.4]
         shell                         [SSH-CONNECT, Section 6.5]
         exec                          [SSH-CONNECT, Section 6.5]
         subsystem                     [SSH-CONNECT, Section 6.5]
         window-change                 [SSH-CONNECT, Section 6.7]
         xon-xoff                      [SSH-CONNECT, Section 6.8]
         signal                        [SSH-CONNECT, Section 6.9]
         exit-status                   [SSH-CONNECT, Section 6.10]
         exit-signal                   [SSH-CONNECT, Section 6.10]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;连接协议子系统名&quot;&gt;连接协议子系统名&lt;/h3&gt;

&lt;p&gt;暂无&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.openssh.com/specs.html&quot;&gt;OpenSSH Specifications&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;这是OpenSSH所展现的最直接的资料页面，但是有很多细节部分的规格与实现没有罗列。而且RFC文档错综复杂，有很多地方都引用不全必须靠“幸运”才能翻看到。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4251&quot;&gt;The Secure Shell (SSH) Protocol Architecture&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;SSH协议架构的rfc页面，它将SSH分为三部分，传输、认证和连接。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4250&quot;&gt;The Secure Shell (SSH) Protocol Assigned Numbers&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;规定协议中各种ID（宏）所使用的序号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4254&quot;&gt;The Secure Shell (SSH) Connection Protocol&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;规定SSH连接协议。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/openssh/openssh-portable&quot;&gt;OpenSSH Portable&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;OpenSSH的源码。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2015-05-01T00:00:00+08:00&quot;&gt;
                2015-05-01
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Fri, 01 May 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/05/01/SSH_connection/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/05/01/SSH_connection/</guid>
        
        <category>rfc</category>
        
        <category>网络协议</category>
        
        
        <category>SSH</category>
        
      </item>
    
      <item>
        <title>在Clion中使用Google Test(gtest)进行程序测试</title>
        
        
        <description> &lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#c测试框架&quot; id=&quot;markdown-toc-c测试框架&quot;&gt;C++测试框架&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#boost-test&quot; id=&quot;markdown-toc-boost-test&quot;&gt;Boost Test&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#google-test&quot; id=&quot;markdown-toc-google-test&quot;&gt;Google Test&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#catch&quot; id=&quot;markdown-toc-catch&quot;&gt;CATCH&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#google-test-in-clion&quot; id=&quot;markdown-toc-google-test-in-clion&quot;&gt;Google Test in Clion&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#样例项目下载&quot; id=&quot;markdown-toc-样例项目下载&quot;&gt;样例项目下载&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#reference&quot; id=&quot;markdown-toc-reference&quot;&gt;Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/14/bug_fixed.svg&quot; /&gt;&lt;/div&gt;

&lt;p&gt;我第一次接触到&lt;strong&gt;程序测试&lt;/strong&gt;是在大学的时候，那个时候对于程序测试的概念特别模糊，一方面是因为对于能推出新产品的“开发”工作比较有热情，一方面也是因为大学时候与测试有关的课程老师授课的时候往往都没有相关的理论论述，取而代之的大多都是反复的一遍又一遍地让我们试错，实在是乏味。&lt;/p&gt;

&lt;p&gt;我开始理解测试，又或者说之所以有这篇文章，是因为在某些特定的环境下，测试是一个&lt;strong&gt;特别值得独立出来的，能提高整体效率的工作流程&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;那就是，一方面作品需要验证其准确性，一方面又不便因验证本身而大改项目的整体结构的时候。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;测试框架能良好的发挥其&lt;strong&gt;松散&lt;/strong&gt;的，&lt;strong&gt;准确&lt;/strong&gt;的，&lt;strong&gt;多入口&lt;/strong&gt;的特性。将整个项目的工作流程调整成“需求-&amp;gt;设计-&amp;gt;开发-&amp;gt;[测试-&amp;gt;调试]多批次并行循环-&amp;gt;发布”，能让整个工程变得简洁而有序，哪怕仅仅是团队仅仅是一个人。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;c测试框架&quot;&gt;C++测试框架&lt;/h2&gt;

&lt;p&gt;在Clion中为C++提供了三个主流的测试框架作为配置选项：&lt;a href=&quot;https://www.boost.org/doc/libs/1_66_0/libs/test/doc/html/index.html&quot;&gt;Boost.test&lt;/a&gt;，&lt;a href=&quot;https://github.com/catchorg/Catch2/blob/master/docs/limitations.md&quot;&gt;Catch&lt;/a&gt;，&lt;a href=&quot;https://github.com/google/googletest&quot;&gt;Google Test&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;boost-test&quot;&gt;Boost Test&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;

&lt;p&gt;Boost Test是一个很不错的选择，尤其是当你正在使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Boost&lt;/code&gt;的时候。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// TODO: Include your class to test here.&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define BOOST_TEST_MODULE MyTest
#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;boost/test/unit_test.hpp&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;BOOST_AUTO_TEST_CASE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyTestCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// To simplify this example test, let&apos;s suppose we&apos;ll test &apos;float&apos;.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Some test are stupid, but all should pass.&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;9.5&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;BOOST_CHECK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BOOST_CHECK_EQUAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BOOST_CHECK_CLOSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;9.5&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0001&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Checks differ no more then 0.0001%&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;它支持：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;自动&lt;/strong&gt;或者手动测试注册&lt;/li&gt;
  &lt;li&gt;大量的断言&lt;/li&gt;
  &lt;li&gt;自动地对比&lt;strong&gt;collections&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;多种多样的输出格式（包括&lt;strong&gt;XML&lt;/strong&gt;）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Fixtures&lt;/strong&gt;/&lt;strong&gt;模板&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;google-test&quot;&gt;Google Test&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;

&lt;p&gt;Google Test（也被叫做Google C++ 测试框架）是一个较新的测试框架。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;gtest/gtest.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;TEST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyTestSuitName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyTestCaseName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;EXPECT_GT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;EXPECT_EQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Should be equal to one&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;它的主要特性：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;便携&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;提供致命和&lt;strong&gt;非致命&lt;/strong&gt;的断言&lt;/li&gt;
  &lt;li&gt;可以给断言的输出提供简单的信息数据：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASSERT_EQ(5, Foo(i)) &amp;lt;&amp;lt; &quot; where i = &quot; &amp;lt;&amp;lt; i;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Google Test可以&lt;strong&gt;自动地&lt;/strong&gt;检测到你的测试任务所以你不需要枚举他们到列表中再运行&lt;/li&gt;
  &lt;li&gt;可以轻松地&lt;strong&gt;拓展&lt;/strong&gt;你的断言的词汇&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Death tests&lt;/strong&gt;（详情请见高级教程）&lt;/li&gt;
  &lt;li&gt;为子程序循环提供&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SCOPED_TRACE&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;你可以决定&lt;strong&gt;运行哪一些测试任务&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;生成&lt;strong&gt;XML&lt;/strong&gt;形式的测试报告&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Fixtures&lt;/strong&gt;/&lt;strong&gt;Mock&lt;/strong&gt;/&lt;strong&gt;模板&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;catch&quot;&gt;CATCH&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;仅仅需要导入头文件&lt;/li&gt;
  &lt;li&gt;自动注册tests的方法和函数&lt;/li&gt;
  &lt;li&gt;将标准C++表达式分解到LHS和RHS（所以你不需要一套的断言宏）&lt;/li&gt;
  &lt;li&gt;Support for nested sections within a function based fixture&lt;/li&gt;
  &lt;li&gt;可以用自然语言为测试命名，相应的函数和方法将生成&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/catchorg/Catch2/blob/master/docs/why-catch.md#top&quot;&gt;更多&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;google-test-in-clion&quot;&gt;Google Test in Clion&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;创建新的C++ Executable项目。
    &lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:100%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/14/Snipaste_2019-04-14_20-17-57.png&quot; /&gt;&lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;将项目分为&lt;strong&gt;项目&lt;/strong&gt;和&lt;strong&gt;测试&lt;/strong&gt;目录，并在项目目录中添加&lt;strong&gt;头文件&lt;/strong&gt;和&lt;strong&gt;源文件&lt;/strong&gt;目录。为测试目录（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Test_DIR&lt;/code&gt;）添加具体测试目录（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tests&lt;/code&gt;），并为其添加&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;。之后将&lt;a href=&quot;https://github.com/google/googletest&quot;&gt;gtest源码&lt;/a&gt;添加到测试lib目录（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Test_DIR/lib&lt;/code&gt;）中并为测试目录添加&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;，并为项目添加源码。
    &lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:40%;&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/14/Snipaste_2019-04-14_20-39-45.png&quot; /&gt;&lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编写根目录的CMakeLists，它有两个作用：程序的完整功能、将测试CMakeLists引入。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; cmake_minimum_required(VERSION 3.13)
 project(Test)
    
 set(CMAKE_CXX_STANDARD 14)
    
 #头文件目录
 include_directories(Project_DIR/Header)
    
 #链接
 add_executable(Test main.cpp Project_DIR/Source/IamAClass.cpp)
    
 #为项目引入测试功能
 add_subdirectory(Test_DIR) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;编写项目源码。
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// Created by anon on 2019/4/14.&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
    
 &lt;span class=&quot;cp&quot;&gt;#ifndef TEST_IAMACLASS_H
&lt;/span&gt; &lt;span class=&quot;cp&quot;&gt;#define TEST_IAMACLASS_H
&lt;/span&gt;    
    
 &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IamAClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
     &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;return_Zero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    
    
 &lt;span class=&quot;cp&quot;&gt;#endif //TEST_IAMACLASS_H
&lt;/span&gt;    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// Created by anon on 2019/4/14.&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
    
 &lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&quot;IamAClass.h&quot;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;    
 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IamAClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;return_Zero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编写&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Test_DIR/CMakeLists.txt&lt;/code&gt;。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; add_subdirectory(lib/googletest-master)
 add_subdirectory(tests)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Test_DIR/tests/CMakeLists.txt&lt;/code&gt;设置项目名称、链接文件、导入库文件，并为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tests&lt;/code&gt;添加两个测试文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;testFILE_1.cpp&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;testFILE_2.cpp&lt;/code&gt;。&lt;/p&gt;

    &lt;p&gt;CMakeLists.txt&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; add_executable(run_actual_tests testFILE_1.cpp testFILE_2.cpp  ../../Project_DIR/Source/IamAClass.cpp)
    
 target_link_libraries(run_actual_tests gtest gtest_main)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;testFILE_1.cpp&lt;/p&gt;
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// Created by anon on 2019/4/14.&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
    
 &lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&quot;gtest/gtest.h&quot;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt; &lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&quot;IamAClass.h&quot;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;    
 &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;IamAClass&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_IamClass_obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
 &lt;span class=&quot;n&quot;&gt;TEST_F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TestClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Test_ReturnZeroMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;ASSERT_EQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test_IamClass_obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;return_Zero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
 &lt;span class=&quot;n&quot;&gt;TEST_F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TestClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Test_ReturnZeroMethod_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;ASSERT_EQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test_IamClass_obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;return_Zero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;testFILE_2.cpp&lt;/p&gt;
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// Created by anon on 2019/4/14.&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
    
 &lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&quot;gtest/gtest.h&quot;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;    
 &lt;span class=&quot;n&quot;&gt;TEST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SUITE_A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TEST_A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;ASSERT_EQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;TEST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SUITE_A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TEST_B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;ASSERT_EQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;TEST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SUITE_B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TEST_A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;ASSERT_EQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;TEST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SUITE_B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TEST_B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;ASSERT_EQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;编译运行target&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run_actual_tests&lt;/code&gt;（如果不存在这个配置选项，可以手动添加cmake类型）。
    &lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/14/Snipaste_2019-04-14_21-26-31.png&quot; /&gt;&lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;使用Clion内置的Google Test配置工具，进行特定SUITE的测试。
    &lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/14/Snipaste_2019-04-14_21-30-14.png&quot; /&gt;&lt;/div&gt;
    &lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;height:;width:&quot; alt=&quot;&quot; title=&quot;&quot; src=&quot;/image/2019/04/14/Snipaste_2019-04-14_21-31-38.png&quot; /&gt;&lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;样例项目下载&quot;&gt;样例项目下载&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/eMous/GoogleTestClionExample.git&quot;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/242926/comparison-of-c-unit-test-frameworks&quot;&gt;StackOverflow@Wernight&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/242926/comparison-of-c-unit-test-frameworks&quot;&gt;StackOverflow@Wernight&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/242926/comparison-of-c-unit-test-frameworks&quot;&gt;CATCH原作者：StackOverflow@philsquared&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
 &lt;div class=&quot;copyright&quot;&gt;
        &lt;h4&gt;文档信息&lt;/h4&gt;
        &lt;ul&gt;
            &lt;li&gt;作者: 
                
                    LiangLab
                
                
                
                &lt;a href=&quot;mailto:devtsai@outlook.com&quot; title=&quot;devtsai@outlook.com&quot;&gt;&lt;i class=&quot;far fa-envelope-open&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt; 
                 
            &lt;/li&gt;
            
            
            &lt;li&gt;发表日期： &lt;abbr title=&quot;2015-04-14T00:00:00+08:00&quot;&gt;
                2015-04-14
               &lt;/abbr&gt;&lt;/li&gt;
            &lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名（&lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot;&gt;创意共享3.0许可证&lt;/a&gt;）&lt;/li&gt;
            &lt;li&gt;若文章中存在事实上的错误，欢迎评论或与作者联系。&lt;/li&gt;
        &lt;/ul&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .copyright{
            margin-top:1em;
            padding:1em;
            border:1px solid #d3d3d3;
            background-color:#DEEBF7;
        }
        
        .copyright h4{
            margin-top: 2px;
            border-bottom:1px solid gray;
            font-size:1.5em;
            font-weight:bold;
            color:#556677;
        }
        
        .copyright ul{
            padding-left:2em;
            padding-right:2em;
        }
        
        .copyright li{
            color:#556677;
        }
&lt;/style&gt;
      </description>
        <pubDate>Tue, 14 Apr 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2015/04/14/UseGtestInClion/</link>
        <guid isPermaLink="true">http://localhost:4000/2015/04/14/UseGtestInClion/</guid>
        
        <category>测试</category>
        
        <category>Webstorm</category>
        
        <category>gtest</category>
        
        <category>C++</category>
        
        
        <category>测试</category>
        
      </item>
    
  </channel>
</rss>
